module frech.Protocol where

import Control.Concurrent(MVar)

import frech.Daten
-- import frech.FEN(decodeFEN)

-- when the drive receives 'NoMore' or 'EOF' there won\'t be something to read from this 'MVar'
data Input = Line String | EOF | MV Move | NoMore
deriving Eq Input

type Command = Bool


data State = FORCED | PLAYING | THINKING
data GameState = GS { 
        history :: [Position], 
        state :: State, 
        player :: Player,
        rvar, tvar :: MVar Command,
        ivar       :: MVar Input,
    } where {
    current GS{history} = head history
}


reader :: MVar Command -> MVar Input -> IO ()
reader cvar dvar = do
    input <- fmap Line getLine `catch` (\(x::EOFException) -> pure EOF)
    dvar.put input
    if input == EOF then pure ()
    else do
        continue <- cvar.take
        if continue then reader cvar dvar else pure ()

type Strategy = GameState -> MVar Command -> MVar Input -> IO ()

strategy1 ∷ Strategy
strategy1 gs cin cout = do
    if true  -- there is a next move
    then do
        m <- pure M{player=WHITE, piece=PAWN, promote=EMPTY, from=E2, to=E4}
        -- this could have taken a while, let's see if we got something meanwhile
        abort ← cin.poll
        case abort of
            Just false → pure ()   -- abort
            Just true  → println "# protocol error, got CONTINUE before sending move" >> stdout.flush
            Nothing    → do 
                cout.put (MV m)
                continue <- cin.take
                if continue then strategy1 gs cin cout else pure ()
    else do 
        cout.put NoMore
        pure ()

protocol :: Strategy → GameState → IO ()
protocol strategy gs  = do
    case gs.state of
        FORCED → do
            cmd ← gs.ivar.take
            case cmd of
                EOF     → pure ()   -- too bad
                MV _    → do 
                    println "# protocol error, got a move in forced mode." >> stdout.flush
                    gs.tvar.offer false
                    protocol strategy gs
                NoMore  → do
                    println "# protocol error, got NoMore in forced mode." >> stdout.flush
                    protocol strategy gs
                Line command → do
                    gs.rvar.put true
                    process command gs >>= protocol strategy
    pure ()


process ∷ String → GameState → IO GameState
process command gs = do
    case command of
        '^\s*(accepted|rejected|xboard|random|cores|hard|easy|post)\b'    
                            → pure gs
        '^\s*protover '     → do
            println ("feature ping=0 setboard=1 playother=1 usermove=1 draw=0 "
                        ++ "sigint=0 analyze=0 variants=\"normal\" colors=0 nps=0 "
                        ++ "debug=1 memory=0 smp=1 "
                        ++ "done=1")
            stdout.flush
            pure gs
        '^\s*new\b'         → pure gs.{history=[initialBoard], state=PLAYING, player=BLACK}
        '^\s*quit\b'        → pure gs
        '^\s*force\b'       → pure gs.{state=FORCED}
        '^\s*playother\b'   → pure gs.{state=PLAYING, player = gs.current.turn.opponent}
        '^\s*go\b'          → pure gs.{state=PLAYING, player = gs.current.turn.opponent}
        -- user makes a move
        m~'^\s*usermove ([a-h][1-8])([a-h][1-8])([nbrq]?)\b' → do
            println "# in usermove"
            stdout.flush
            let p    = head gs.history
                from = m.group 1
                to   = m.group 2
                prom = m.group 3
                ms = case (from >>= Index.read, to >>= Index.read, fmap _.toUpperCase prom) of
                    (Just fr, Just t, Just nbrq) 
                        -> filter (\(m::Move) -> m.from == fr 
                                && m.to == t 
                                && (m.promote < KNIGHT && nbrq == "" 
                                    || show m.promote == nbrq
                                    || m.piece == KING)) (moves p)
                    _ -> []
            if null ms
                then do
                    println ("Illegal move: " ++ command.replaceFirst 'usermove ' "")
                    mapM_  (println . ("# " ++) . show) (moves p)
                    stdout.flush
                    pure gs
                else do
                    let mv  = head ms
                        pos = applyMove p mv
                        gs' = gs.{history ← (pos:)}
                    println ("# after " ++ show mv)
                    println ("# " ++ show (whatIsOn pos mv.from))
                    println ("# " ++ show (whatIsOn pos mv.to))
                    stdout.flush 
                    pure gs'
        -- result 
        '^\s*result ' -> pure gs.{state=FORCED}                        
        -- time control (not yet implemented)
        '^\s*(level|st|sd|nps|time|otim)\b'
                            → pure gs
        
        other                   → do
            println ("Error (unknown command): " ++ command)
            stdout.flush
            pure gs
        

think ∷ GameState → IO GameState
think gs = do
        let m   = head (moves (head gs.history))
            pos = applyMove (head gs.history) m
        print "move "
        print m.from
        print m.to
        when (m.promote >= KNIGHT) do
            print (m.promote.show.toLowerCase)
        println ""
        println ("# after " ++ show m)
        println ("# " ++ show (whatIsOn pos m.from))
        println ("# " ++ show (whatIsOn pos m.to)) 

        when (null (moves pos)) do
            if (notInCheck pos)
                then println "1/2-1/2 (Stalemate)"
                else if pos.turn == WHITE
                    then println "0-1 (Black mates)"
                    else println "1-0 (White mates)"
        when (not (null (moves pos)) && pos.getPlyCounter > 99) do
            println "1/2-1/2 (50 moves)"
        when (not (null (moves pos)) && pos.getPlyCounter < 100 && length (filter (==pos) gs.history) > 1) do
            println "1/2-1/2 (repetition)"
        stdout.flush
        pure  gs.{history ← (pos:)}
 
            
--main _ = protocol GS{history=[initialBoard], force=true} 
--    `catch` (\(x::EOFException) -> pure ())
--    `finally` do
--        println "# exiting"
--        stdout.flush
