--- Protocol handler for communication with xboard.
module frech.Protocol 
    inline(Variation.max, Variation.>, Variation.min, Variation.<) where

import Control.Concurrent(MVar, forkIO, forkOS)
import System.Random(randomIO)
import Data.List(sortBy)

import frech.Daten
import frech.FEN(decodeFEN)

data Variation = PV { !moves :: [Move], !val :: Int, !nodes :: Int}
instance Ord Variation where
    hashCode pv = 0
    pv1 < pv2 = pv1.val < pv2.val
    pv1 == pv2 = pv1.val == pv2.val
    pv1 > pv2 = pv1.val > pv2.val
    pv1 <=> pv2 = pv1.val <=> pv2.val
    max pv1 pv2 = if pv1 > pv2 then pv1 else pv2
    min pv1 pv2 = if pv1 < pv2 then pv1 else pv2
deriving Show Variation

--- A bit cheaper than
--- > maximum vs 
goMaximum, goMinimum ∷ Variation → [Variation] → Variation
goMaximum !best (pv:pvs) = goMaximum (max best pv) pvs
goMaximum !best []       = best 
goMinimum !best (pv:pvs) = goMinimum (min best pv) pvs
goMinimum !best []       = best 


--- when the driver receives 'NoMore' or 'EOF' there won\'t be something to read from this 'MVar'thereafter
data Input = 
        Line String     --- Sent by input reader when it has read a line of input.
        | EOF           --- Sent by the input reader when there is no more input. 
        | MV !Int !Variation --- Sent by strategy identified by some number when it has found a 'Move'
        | NoMore Int    --- Sent by strategy identified by some number when it can't find more 'Move's.
deriving Eq Input
deriving Show Input

type Command = Bool
type Clock   = Long


data State = FORCED | PLAYING | THINKING Clock | TERMINATED
derive Show State

type Strategy = GameState -> MVar Command -> MVar Input -> IO ()

data GameState = GS { 
        !history :: [Position]       {-- 'Position's reached since last "new" or "setboard" xboard-command.
                                        The head of this non-empty list is the current position.
                                        The last entry is 'initialBoard' in case of "new" or the 
                                        'Position' received through "setboard".
                                        
                                         This list is shortened only on xboard "undo" commands.
                                         The implementation will refuse to undo the initial 'Position'. -} 
        !state :: State              {-- 
                                        Are we in force mode, playing or thinking?
                                        In 'THINKING' a strategy task will be active. -}      
        !player :: Player            --- The colour we are playing.
        !rvar, !tvar :: MVar Command  {-- 
                                        Commands are sent to the reader or strategy task through this 
                                        'MVar's. Normally every input must be answered immediately
                                        with either *true* for "continue" or *false* for "terminate" except for
                                        the 'EOF' and 'NoMore' messages. The input reader or strategy will
                                        terminate once they send this and not read any answer.
                                        
                                        The driver shall not send any more commands once it has sent "false" 
                                        (though this should not do big harm).
                                        
                                        A strategy must be careful not to send anything over the input
                                        channel when it has received "false". The driver may send "false"
                                        (but not "true")
                                        even before the strategy sends a move to signal that it isn't 
                                        interested anymore in 'Move's for the 'Position' the strategy 
                                        is working on.
                                        This can happen when the driver already sent the previous best move
                                        because the time was running out, or in answer to the "?"
                                        xboard command, or when xboard switched to "force" mode during
                                        thinking.   
                                    --}  
        !ivar       :: MVar Input    --- 'Input' from the 'reader' and strategies.
        !sid        :: Int           {-- 
                                        Strategy identifier. Used to sort out unwanted input from
                                        strategies lagging behind. Incremented on each half-move, so that
                                        only input with an id that matches this 'GameState's sid
                                        is regarded as valid.
                                    -}
        !pings      :: [Int]         --- Ping numbers received during thinking are saved here.
        !best       :: [Variation]    --- Moves reported so far
        !myTime, !oTime ∷ Clock       --- My remaining time and her remaining time in milliseconds
    } 
    where 
        current GS{history} = head history
        --- time per move in milliseconds
        timePerMove gs = max 0 (myTime gs - oTime gs) `quot` 2 
                        + if done >= 50 then myTime gs else myTime gs `quot` 50.long
            where
                done = (if player gs == WHITE then length (history gs) + 1 else length (history gs)) `quot` 2  



reader :: MVar Command -> MVar Input -> IO ()
reader cvar dvar = do
    -- println ("# reader waiting for input")
    -- stdout.flush
    input <- fmap Line getLine `catch` (\(x::EOFException) -> pure EOF)
    -- println ("# reader sending " ++ show input)
    -- stdout.flush 
    dvar.put input
    if input == EOF then pure ()
    else do
        continue <- cvar.take
        -- println ("# reader got answer " ++ show continue)
        -- stdout.flush
        if continue then reader cvar dvar else pure ()

protocol :: Strategy → GameState → IO ()
protocol strategy gs  = do
 
        println ("# protocol state=" ++ gs.state.show ++ ", player=" ++ gs.player.show)
        stdout.flush
        
        case gs.state of
            TERMINATED → pure ()
            FORCED → do
                cmd ← gs.ivar.take
                commandProcessing cmd >>= protocol strategy 
            PLAYING
                | gs.current.turn == gs.player → do
                    cmd ← gs.ivar.poll
                    maybe (think strategy gs) commandProcessing cmd >>= protocol strategy
                | otherwise → gs.ivar.take >>= commandProcessing >>= protocol strategy
            THINKING since = do
                now ← System.currentTimeMillis ()
                let time = max 500 (gs.timePerMove - (now - since))
                cmd ← gs.ivar.wait time.int
                case cmd of
                    Nothing → do                    -- time out while thinking
                        println "# Thinking timed out." >> stdout.flush
                        gs.tvar.offer false         -- tell strategy to finish
                        sendMove gs >>= protocol strategy
                    Just EOF → do
                        println "# EOF on standard input while thinking!?" >> stdout.flush
                        gs.tvar.offer false 
                        pong gs.pings
                        pure ()
                    Just (MV id pv)
                        | id == gs.sid = do
                            now ← System.currentTimeMillis ()
                            let continue = (now - since) < (9 * gs.timePerMove) `quot` 10
                                report   = length pv.moves > 3 || null gs.best
                                                || (if gs.player == WHITE then pv.val >= goMaximum gs.best
                                                                          else pv.val <= goMinimum gs.best)
                                nodes = fold (+) pv.nodes (map _.nodes gs.best)
                            gs.tvar.put continue
                            println ("# we have used " ++ show (now-since) 
                                        ++ "ms of "    ++ show (gs.timePerMove)
                                        ++ "ms, continue=" ++ show continue)
                            now ← System.currentTimeMillis ()
                            println (" " ++ show (length pv.moves)   -- depth
                                ++   " " ++ show (if gs.player == BLACK 
                                                    then negate pv.val
                                                    else pv.val)     -- score in centipawns
                                ++   " " ++ show ((now - since) `quot` 10)  -- time  in centiseconds
                                ++   " " ++ show nodes                    -- nodes
                                ++   " " ++ joined " " (map algebraic pv.moves))
                            stdout.flush
                            let best = pv : filter (\p → head p.moves != head pv.moves) gs.best    
                            if continue 
                                then protocol strategy gs.{best}
                                else sendMove gs.{best} >>= protocol strategy
                        | otherwise = do
                            println "# ignoring move from previous strategy instance." >> stdout.flush
                            protocol strategy gs
                    Just (NoMore id)
                        | id == gs.sid = do
                            println "# No more moves." >> stdout.flush 
                            sendMove gs >>= protocol strategy
                        | otherwise = do
                            println "# ignoring NoMore from previous strategy instance." >> stdout.flush
                            protocol strategy gs
                    -- xboard command while thinking
                    -- we accept ping, force, new, quit, result and ?
                    Just (Line 's*quit\b') → do
                        gs.tvar.offer false
                        gs.rvar.put false
                        pure ()
                    Just (Line xboard) → do
                        gs.rvar.put true 
                        case xboard of
                            m~'^\s*ping\s+(\d+)' → do
                                let p = maybe [] (pure . String.atoi) (m.group 1) 
                                protocol strategy gs.{pings <- (p++)}
                            '^\s*(force|result)\b' → do
                                gs.tvar.offer false 
                                pong gs.pings
                                protocol strategy gs.{state=FORCED, best=[]}
                            '^\s*new\b' → do
                                gs.tvar.offer false 
                                pong gs.pings
                                protocol strategy gs.{history=[initialBoard], best=[],
                                                     state=PLAYING, player=BLACK}
                            "?" → sendMove gs >>= protocol strategy
                            other → do
                                println ("Error (command not legal now): " ++ xboard)
                                stdout.flush
                                protocol strategy gs
                        
        
    where
        think ∷ Strategy → GameState → IO GameState
        think strategy gs = do
            let ms = moves gs.current
                mate = null ms && inCheck gs.current gs.current.turn
                stalemate = null ms && not mate
            if mate || stalemate 
            then do
                println "# thinking finds game that has ended"
                stdout.flush
                pure gs.{state=FORCED, best=[]}
            else do
                now ← System.currentTimeMillis ()
                mv  ← MVar.newEmpty
                forkIO (strategy gs mv gs.ivar)
                pure gs.{state=THINKING now, best=[], tvar=mv}
        commandProcessing cmd = case cmd of
                EOF     → pure gs.{state=TERMINATED}   -- too bad
                MV _ _  → do
                    println "# ignoring an unexpected move." >> stdout.flush
                    gs.tvar.offer false
                    pure gs
                NoMore _ → do
                    println "# ignoring an unexpected NoMore." >> stdout.flush
                    pure gs
                Line command → do
                    xboardCommand command gs
        -- send outstanding pongs
        pong [] = pure ()
        pong (p:ps) = pong ps >> println ("pong " ++ show p) >> stdout.flush
        sendMove ∷ GameState → IO GameState
        sendMove gs = case gs.best of 
                [] →  do            -- now we have a problem, there is no move
                    println "# strategy busy, but no move found yet"
                    println "resign"
                    stdout.flush
                    pong gs.pings
                    pure gs.{state=FORCED, pings=[]}
                variations → do
                    coin ← randomIO
                    let spv = if gs.player == WHITE then sortBy (descending _.val) variations 
                                                    else sortBy (ascending _.val) variations
                        pv = case spv of
                                (pv1:pv2:_) → if coin && abs (pv1.val - pv2.val) < 6 then pv2 else pv1
                                single -> head spv
                        m = head pv.moves
                        pos = applyMove gs.current m
                        ms  = moves pos
                        mate = null ms && inCheck pos pos.turn
                        stalemate = null ms && not mate
                        moves50 = not mate && not stalemate && pos.getPlyCounter > 99
                        repetition = not mate && not stalemate && not moves50 
                                              && length (filter (==pos) gs.history) > 1
                        finished = mate || stalemate || moves50 || repetition
                    println ("# sorted pvs: " ++ show (
                                            map (\p -> (algebraic (head p.moves), p.val)) spv))
                    println ("move " ++ algebraic m)
                    
                    --println ("# after " ++ show m)
                    --println ("# " ++ show (whatIsOn pos m.from))
                    --println ("# " ++ show (whatIsOn pos m.to)) 
            
                    when (stalemate)  do  println "1/2-1/2 {Stalemate}"
                    when (mate)       do  if pos.turn == WHITE
                                            then println "0-1 {Black mates}"
                                            else println "1-0 {White mates}"
                    when (moves50)    do  println "1/2-1/2 {50 moves}"
                    when (repetition) do  println "1/2-1/2 {repetition}"
                    stdout.flush
                    pong gs.pings
                    pure  gs.{history ← (pos:), pings = [], sid ← succ,
                                state = if finished then FORCED else PLAYING,
                                best  = []}
 


xboardCommand ∷ String → GameState → IO GameState
xboardCommand command gs = do
    println ("# xboardCommand: " ++ command)
    stdout.flush
    gs.rvar.put  (command !~ '^\s*quit\b') 
    case command of
        '^\s*(accepted|rejected|xboard|random|cores|hard|easy|post)\b'    
                            → pure gs
        '^\s*protover '     → do
            println ("feature ping=0 setboard=1 playother=1 usermove=1 draw=0 "
                        ++ "sigint=0 analyze=0 variants=\"normal\" colors=0 nps=0 "
                        ++ "debug=1 memory=0 smp=1 "
                        ++ "done=1")
            stdout.flush
            pure gs
        '^\s*new\b'         → pure gs.{history=[initialBoard], state=PLAYING, player=BLACK}
        '^\s*quit\b'        → do
                                gs.tvar.offer false     -- just in case
                                pure gs.{state=TERMINATED}
        '^\s*force\b'       → pure gs.{state=FORCED}
        '^\s*playother\b'   → pure gs.{state=PLAYING, player = gs.current.turn.opponent}
        '^\s*go\b'          → pure gs.{state=PLAYING, player = gs.current.turn}
        -- set the board to FEN
        '^\s*setboard\b'    → 
            case decodeFEN (command.replaceFirst '^\s*setboard\s+' "") of
                Left s → do
                    println ("Error (" ++ s ++ ")") >> stdout.flush
                    pure gs.{state=FORCED}
                Right p → do
                    pure gs.{history=[p], state=FORCED, best=[]}
        -- user makes a move
        m~'^\s*usermove ([a-h][1-8])([a-h][1-8])([nbrq]?)\b' → do
            println "# in usermove"
            stdout.flush
            let p    = head gs.history
                from = m.group 1
                to   = m.group 2
                prom = m.group 3
                ms = case (from >>= Index.read, to >>= Index.read, fmap _.toUpperCase prom) of
                    (Just fr, Just t, Just nbrq) 
                        -> filter (\(m::Move) -> m.from == fr 
                                && m.to == t 
                                && (m.promote < KNIGHT && nbrq == "" 
                                    || show m.promote == nbrq
                                    || m.piece == KING)) (moves p)
                    _ -> []
            if null ms
                then do
                    println ("Illegal move: " ++ command.replaceFirst 'usermove ' "")
                    mapM_  (println . ("# " ++) . algebraic) (moves p)
                    stdout.flush
                    pure gs
                else do
                    let mv  = head ms
                        pos = applyMove p mv
                        gs' = gs.{history ← (pos:), sid ← succ}
                    --println ("# after " ++ show mv)
                    --println ("# " ++ show (whatIsOn pos mv.from))
                    --println ("# " ++ show (whatIsOn pos mv.to))
                    stdout.flush 
                    pure gs'
        -- result 
        '^\s*result ' -> pure gs.{state=FORCED}                        
        -- time control 
        '^\s*(level|st|sd|nps)\b' → pure gs
        '^\s*time\s+\d+' → pure gs.{myTime = 10 * (command.replaceFirst '^\s*time\s+' "").atol}
        '^\s*otim\s+\d+' → pure gs.{oTime  = 10 * (command.replaceFirst '^\s*otim\s+' "").atol}
        
        other                   → do
            println ("Error (unknown command): " ++ command)
            stdout.flush
            pure gs
        
