--- Protocol handler for communication with xboard.
module frech.Protocol 
    inline(Variation.max, Variation.>, Variation.min, Variation.<) where

import Control.Concurrent(MVar, forkIO, forkOS)
import System.Random(randomIO)
import Data.List(sortBy)
import Data.Bits(.^.)

import frech.Daten
import frech.FEN(decodeFEN)

data Variation = PV { !moves :: [Move], !val :: Int, !nodes :: Int}
instance Ord Variation where
    hashCode pv = 0
    pv1 < pv2 = pv1.val < pv2.val
    pv1 == pv2 = pv1.val == pv2.val
    pv1 > pv2 = pv1.val > pv2.val
    pv1 <=> pv2 = pv1.val <=> pv2.val
    max pv1 pv2 = if pv1 > pv2 then pv1 else pv2
    min pv1 pv2 = if pv1 < pv2 then pv1 else pv2
deriving Show Variation

--- A bit cheaper than
--- > maximum vs 
goMaximum, goMinimum ∷ Variation → [Variation] → Variation
goMaximum !best (pv:pvs) = goMaximum (max best pv) pvs
goMaximum !best []       = best 
goMinimum !best (pv:pvs) = goMinimum (min best pv) pvs
goMinimum !best []       = best 


--- when the driver receives 'NoMore' or 'EOF' there won\'t be something to read from this 'MVar'thereafter
data Input = 
        Line String     --- Sent by input reader when it has read a line of input.
        | EOF           --- Sent by the input reader when there is no more input. 
        | MV !Int ![Variation] --- Sent by strategy identified by some number when it has found a 'Move'
        | Forget Int    --- Sent by strategy when all previously computed variations should get forgotten 
        | NoMore Int    --- Sent by strategy identified by some number when it can't find more 'Move's.
deriving Eq Input
deriving Show Input

type Command = Bool
type Clock   = Long


data State = FORCED | PLAYING | THINKING Clock | TERMINATED
derive Show State

type Strategy = GameState -> MVar Command -> MVar Input -> IO ()

data TimeControl = TC {
        !myTime, !oTime ∷ Clock         --- My remaining time and her remaining time in milliseconds
        !lvlMoves   :: Int              --- How many moves per game, if 0 then incremental 
        !lvlTime    :: Clock            --- Time for entire game
        !lvlIncr    :: Clock            --- incremental time
    }


data GameState = GS {
        !name ∷ String              --- identification 
        !history :: [Position]       {-- 'Position's reached since last "new" or "setboard" xboard-command.
                                        The head of this non-empty list is the current position.
                                        The last entry is 'initialBoard' in case of "new" or the 
                                        'Position' received through "setboard".
                                        
                                         This list is shortened only on xboard "undo" commands.
                                         The implementation will refuse to undo the initial 'Position'. -} 
        !state :: State              {-- 
                                        Are we in force mode, playing or thinking?
                                        In 'THINKING' a strategy task will be active. -}      
        !player :: Player            --- The colour we are playing.
        !rvar, !tvar :: MVar Command  {-- 
                                        Commands are sent to the reader or strategy task through this 
                                        'MVar's. Normally every input must be answered immediately
                                        with either *true* for "continue" or *false* for "terminate" except for
                                        the 'EOF' and 'NoMore' messages. The input reader or strategy will
                                        terminate once they send this and not read any answer.
                                        
                                        The driver shall not send any more commands once it has sent "false" 
                                        (though this should not do big harm).
                                        
                                        A strategy must be careful not to send anything over the input
                                        channel when it has received "false". The driver may send "false"
                                        (but not "true")
                                        even before the strategy sends a move to signal that it isn't 
                                        interested anymore in 'Move's for the 'Position' the strategy 
                                        is working on.
                                        This can happen when the driver already sent the previous best move
                                        because the time was running out, or in answer to the "?"
                                        xboard command, or when xboard switched to "force" mode during
                                        thinking.   
                                    --}  
        !ivar       :: MVar Input    --- 'Input' from the 'reader' and strategies.
        !sid        :: Int           {-- 
                                        Strategy identifier. Used to sort out unwanted input from
                                        strategies lagging behind. Incremented on each half-move, so that
                                        only input with an id that matches this 'GameState's sid
                                        is regarded as valid.
                                    -}
        !pings      :: [Int]            --- Ping numbers received during thinking are saved here.
        !best, !backup  :: [Variation]  --- Moves reported so far, and backup
        !myTime, !oTime ∷ Clock         --- My remaining time and her remaining time in milliseconds
        !cores          ∷ Int           --- # of cores we're allowed to use
    } 
    where 
        current GS{history} = head history
        --- Time per move in milliseconds
        --- This is just enough to make approximate 10 more moves, however, 
        timePerMove ∷ GameState → Long
        timePerMove gs = max 0 (gs.myTime - gs.oTime) `quot` 3          -- we are ahead in time 
                        + max 1000 (gs.myTime `quot` 20)                -- 1 second or enough to play 20 moves 



reader :: MVar Command -> MVar Input -> IO ()
reader cvar dvar = do
    -- println ("# reader waiting for input")
    -- stdout.flush
    input <- fmap Line getLine `catch` (\(x::EOFException) -> pure EOF)
    -- println ("# reader sending " ++ show input)
    -- stdout.flush 
    dvar.put input
    if input == EOF then pure ()
    else do
        continue <- cvar.take
        -- println ("# reader got answer " ++ show continue)
        -- stdout.flush
        if continue then reader cvar dvar else pure ()

protocol :: Strategy → GameState → IO ()
protocol strategy gs  = do
 
        println ("# protocol state=" ++ gs.state.show ++ ", player=" ++ gs.player.show
                    ++ ". cores=" ++ show gs.cores)
        stdout.flush
        
        case gs.state of
            TERMINATED → pure ()
            FORCED → do
                cmd ← gs.ivar.take
                commandProcessing cmd >>= protocol strategy 
            PLAYING
                | gs.current.turn == gs.player → do
                    cmd ← gs.ivar.poll
                    maybe (think strategy gs) commandProcessing cmd >>= protocol strategy
                | otherwise → gs.ivar.take >>= commandProcessing >>= protocol strategy
            THINKING since = do
                now ← System.currentTimeMillis ()
                let time = max 500 (gs.timePerMove - (now - since))
                    -- when we don't have a move yet, wait at all costs, rather than to resign
                    todo = if null gs.best && null gs.backup 
                            then Just <$> gs.ivar.take 
                            else gs.ivar.wait time.int
                cmd ← todo
                case cmd of
                    Nothing → do                    -- time out while thinking
                        println "# Thinking timed out." >> stdout.flush
                        gs.tvar.offer false         -- tell strategy to finish
                        finishThinking ()
                        sendMove gs >>= protocol strategy
                    Just EOF → do
                        println "# EOF on standard input while thinking!?" >> stdout.flush
                        gs.tvar.offer false 
                        pong gs.pings
                        pure ()
                    Just (Forget sid)
                        | sid == gs.sid = do
                            println "# forgetting previous variations"
                            stdout.flush
                            protocol strategy gs.{backup = gs.best, best=[]}
                        | otherwise = protocol strategy gs
                    Just (MV id pvs)
                        | id == gs.sid = do
                            now ← System.currentTimeMillis ()
                            let continue = (now - since) < (9 * gs.timePerMove) `quot` 10
                                nodes = fold (+) (sum (map _.nodes gs.best)) (map _.nodes pvs)
                            gs.tvar.put continue
                            println ("# we have used " ++ show (now-since) 
                                        ++ "ms of "    ++ show (gs.timePerMove)
                                        ++ "ms, continue=" ++ show continue)
                            now ← System.currentTimeMillis ()
                            mapM_ (\pv -> println (
                                    " " ++ show (maximum (map (length . _.moves) (pvs++gs.best)))   -- depth
                                ++  " " ++ show (if gs.player == BLACK 
                                                    then negate pv.val
                                                    else pv.val)     -- score in centipawns
                                ++   " " ++ show ((now - since) `quot` 10)  -- time  in centiseconds
                                ++   " " ++ show nodes                    -- nodes
                                ++   " " ++ joined " " (map algebraic pv.moves))) pvs
                            stdout.flush
                            let best = pvs ++ filter (
                                    \p → head p.moves `notElem` map (head . _.moves) pvs) gs.best    
                            if continue 
                                then protocol strategy gs.{best}
                                else finishThinking () >> sendMove gs.{best} >>= protocol strategy
                        | otherwise = do
                            println "# ignoring move from previous strategy instance." >> stdout.flush
                            protocol strategy gs
                    Just (NoMore id)
                        | id == gs.sid = do
                            println "# No more moves." >> stdout.flush 
                            sendMove gs >>= protocol strategy
                        | otherwise = do
                            println "# ignoring NoMore from previous strategy instance." >> stdout.flush
                            protocol strategy gs
                    -- xboard command while thinking
                    -- we accept ping, force, new, quit, result and ?
                    Just (Line 's*quit\b') → do
                        gs.tvar.offer false
                        gs.rvar.put false
                        pure ()
                    Just (Line xboard) → do
                        gs.rvar.put true 
                        case xboard of
                            m~'^\s*ping\s+(\d+)' → do
                                let p = maybe [] (pure . String.atoi) (m.group 1) 
                                protocol strategy gs.{pings <- (p++)}
                            '^\s*(force|result)\b' → do
                                gs.tvar.offer false 
                                pong gs.pings
                                protocol strategy gs.{state=FORCED, best=[], backup=[]}
                            '^\s*new\b' → do
                                gs.tvar.offer false 
                                pong gs.pings
                                protocol strategy gs.{history=[initialBoard], best=[], backup=[],
                                                     state=PLAYING, player=BLACK}
                            "?" → sendMove gs >>= protocol strategy
                            other → do
                                println ("Error (command not legal now): " ++ xboard)
                                stdout.flush
                                protocol strategy gs
                        
        
    where
        think ∷ Strategy → GameState → IO GameState
        think strategy gs = do
            let ms = moves gs.current
                mate = null ms && inCheck gs.current gs.current.turn
                stalemate = null ms && not mate
            if mate || stalemate 
            then do
                println "# thinking finds game that has ended"
                stdout.flush
                pure gs.{state=FORCED, best=[], backup=[]}
            else do
                now ← System.currentTimeMillis ()
                mv  ← MVar.newEmpty
                beginThinking ()
                forkIO (strategy gs mv gs.ivar)
                pure gs.{state=THINKING now, best=[], backup=[], tvar=mv}
        commandProcessing cmd = case cmd of
                EOF     → pure gs.{state=TERMINATED}   -- too bad
                Forget _ -> pure gs
                MV  _ _  → do
                    println "# ignoring an unexpected move." >> stdout.flush
                    gs.tvar.offer false
                    pure gs
                NoMore _ → do
                    println "# ignoring an unexpected NoMore." >> stdout.flush
                    pure gs
                Line command → do
                    xboardCommand command gs
        -- send outstanding pongs
        pong [] = pure ()
        pong (p:ps) = pong ps >> println ("pong " ++ show p) >> stdout.flush
        sendMove ∷ GameState → IO GameState
        sendMove gs = case gs.best of 
                [] 
                    | not (null gs.backup) → do
                            println "# WARNING: WE NEED TO USE THE BACKUP"
                            stdout.flush
                            sendMove gs.{best=gs.backup, backup=[]}
                    | otherwise →  do            -- now we have a problem, there is no move
                            println "# strategy busy, but no move found yet"
                            println "resign"
                            stdout.flush
                            pong gs.pings
                            pure gs.{state=FORCED, pings=[]}
                variations → do
                    coin ← randomIO
                    let spv = if gs.player == WHITE then sortBy (descending _.val) variations 
                                                    else sortBy (ascending _.val) variations
                        pv = case spv of
                                (pv1:pv2:_) → if coin && abs (pv1.val - pv2.val) < 6 then pv2 else pv1
                                single -> head spv
                        m = head pv.moves
                        pos = applyMove gs.current m
                        ms  = moves pos
                        mate = null ms && inCheck pos pos.turn
                        stalemate = null ms && not mate
                        moves50 = not mate && not stalemate && pos.getPlyCounter > 99
                        repetition = not mate && not stalemate && not moves50 
                                              && length (filter (==pos) gs.history) > 1
                        finished = mate || stalemate || moves50 || repetition
                    checkApplyMove gs.current m pos
                    println ("# sorted pvs: " ++ show (
                                            map (\p -> (algebraic (head p.moves), p.val)) spv))
                    println ("move " ++ algebraic m)
                    
                    --println ("# after " ++ show m)
                    --println ("# " ++ show (whatIsOn pos m.from))
                    --println ("# " ++ show (whatIsOn pos m.to)) 
            
                    when (stalemate)  do  println "1/2-1/2 {Stalemate}"
                    when (mate)       do  if pos.turn == WHITE
                                            then println "0-1 {Black mates}"
                                            else println "1-0 {White mates}"
                    when (moves50)    do  println "1/2-1/2 {50 moves}"
                    when (repetition) do  println "1/2-1/2 {repetition}"
                    stdout.flush
                    pong gs.pings
                    pure  gs.{history ← (pos:), pings = [], sid ← succ,
                                state = if finished then FORCED else PLAYING,
                                best  = []}
 
fmt :: Long → String
fmt = "0x%016L".format

checkApplyMove :: Position → Move → Position → IO ()
checkApplyMove pos1 move pos2 = do
    when (pos2.zobrist != pos2.hash) do
        println "# ZOBRIST HASH FAILURE"
        println ("# in position  " ++ show pos1)
        println ("# applied move " ++ show move)
        println ("# result posn  " ++ show pos2)
        println ("# hash is " ++ fmt pos2.hash 
              ++ ", should be " ++ fmt pos2.zobrist 
              ++ " delta " ++ fmt (pos2.zobrist .^. pos2.hash))
        stdout.flush      
        pure ()


xboardCommand ∷ String → GameState → IO GameState
xboardCommand command gs = do
    println ("# xboardCommand: " ++ command)
    stdout.flush
    gs.rvar.put  (command !~ '^\s*quit\b') 
    case command of
        '^\s*(accepted|rejected|xboard|random|hard|easy|post)\b'    
                            → pure gs
        m~'^\s*cores\s+(\d+)' → case m.group 1 of
                                    Just c → do
                                        println ("# setting cores to " ++ show (atoi c)) 
                                        pure gs.{cores = atoi c}
                                    Nothing → do
                                        println ("# cannot set cores???") >> stdout.flush 
                                        pure gs
        '^\s*protover '     → do
            println ("feature name=\"frech " ++ gs.name ++ "\"")
            println ("feature ping=0 setboard=1 playother=1 usermove=1 draw=0 "
                        ++ "sigint=0 analyze=0 variants=\"normal\" colors=0 nps=0 "
                        ++ "debug=1 memory=0 smp=1 "
                        ++ "done=1")
            stdout.flush
            pure gs
        '^\s*new\b'         → pure gs.{history=[initialBoard], state=PLAYING, player=BLACK}
        '^\s*quit\b'        → do
                                gs.tvar.offer false     -- just in case
                                pure gs.{state=TERMINATED}
        '^\s*force\b'       → pure gs.{state=FORCED}
        '^\s*playother\b'   → pure gs.{state=PLAYING, player = gs.current.turn.opponent}
        '^\s*go\b'          → pure gs.{state=PLAYING, player = gs.current.turn}
        -- set the board to FEN
        '^\s*setboard\b'    → 
            case decodeFEN (command.replaceFirst '^\s*setboard\s+' "") of
                Left s → do
                    println ("Error (" ++ s ++ ")") >> stdout.flush
                    pure gs.{state=FORCED}
                Right p → do
                    pure gs.{history=[p], state=FORCED, best=[]}
        -- user makes a move
        m~'^\s*usermove ([a-h][1-8])([a-h][1-8])([nbrq]?)\b' → do
            println "# in usermove"
            stdout.flush
            let p    = head gs.history
                from = m.group 1
                to   = m.group 2
                prom = m.group 3
                ms = case (from >>= Index.read, to >>= Index.read, fmap _.toUpperCase prom) of
                    (Just fr, Just t, Just nbrq) 
                        -> filter (\(m::Move) -> m.from == fr 
                                && m.to == t 
                                && (m.promote < KNIGHT && nbrq == "" 
                                    || show m.promote == nbrq
                                    || m.piece == KING)) (moves p)
                    _ -> []
            if null ms
                then do
                    println ("Illegal move: " ++ command.replaceFirst 'usermove ' "")
                    mapM_  (println . ("# " ++) . algebraic) (moves p)
                    stdout.flush
                    pure gs
                else do
                    let mv  = head ms
                        pos = applyMove p mv
                        gs' = gs.{history ← (pos:), sid ← succ}
                    --println ("# after " ++ show mv)
                    --println ("# " ++ show (whatIsOn pos mv.from))
                    --println ("# " ++ show (whatIsOn pos mv.to))
                    checkApplyMove p mv pos
                    pure gs'
        -- result 
        '^\s*result ' -> pure gs.{state=FORCED}
        -- undo moves
        '^\s*undo\b'  → pure gs.{state=FORCED, history ← tail}          -- assuming xboard knows what it does
        '^\s*remove\b'  → pure gs.{history ← tail . tail} -- assuming xboard knows what it does
        -- time control 
        '^\s*(level|st|sd|nps)\b' → pure gs
        '^\s*time\s+\d+' → pure gs.{myTime = 10 * (command.replaceFirst '^\s*time\s+' "").atol}
        '^\s*otim\s+\d+' → pure gs.{oTime  = 10 * (command.replaceFirst '^\s*otim\s+' "").atol}
        
        other                   → do
            println ("Error (unknown command): " ++ command)
            stdout.flush
            pure gs
        
