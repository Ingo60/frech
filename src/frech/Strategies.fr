--- various Strategies, and a main function that selects one
module frech.Strategies where

import frege.control.Concurrent(forkOS, MVar)
import Data.List(sortBy)
import Lib.ForkJoin

import frech.Protocol
import frech.Eval
import frech.Daten

-- type Strategy = GameState -> MVar Command -> MVar Input -> IO ()


initialGS = do
    rvar ← MVar.newEmpty
    tvar ← MVar.newEmpty
    ivar ← MVar.newEmpty
    pure GS{history=[initialBoard], state=FORCED, player=BLACK, 
            rvar, tvar, ivar, sid=0, pings=[], best=Nothing, timePerMove=30000} 

main [] = main ["best"]            
main [arg] = do
    gs ← initialGS
    forkOS (reader gs.rvar gs.ivar)
    let strategy = case arg of
            "best"      → strategyBest
            "first"     → strategyFirst
            "resign"    → strategyResign
            "minimax"   → strategyMiniMax
            _           → strategyBest   
    protocol strategy gs
    Concurrent.shutdown
main (arg:args) = main [arg] 
     
--- a template for new strategies
strategyTemplate ∷ Strategy
strategyTemplate gs cin cout = do
    if true  -- there is a next move
    then do
        m <- pure M{player=WHITE, piece=PAWN, promote=EMPTY, from=E2, to=E4}
        -- this could have taken a while, let's see if we got something meanwhile
        abort ← cin.poll
        case abort of
            Just false → pure ()   -- abort
            Just true  → println "# protocol error, got CONTINUE before sending move" >> stdout.flush
            Nothing    → do 
                cout.put (MV gs.sid PV{moves=[m], val=0, nodes=1})
                continue <- cin.take
                if continue then strategyTemplate gs cin cout else pure ()
    else do 
        cout.put (NoMore gs.sid)
        pure ()

--- This strategy doesn't know how to play chess, thus it says it doesn't find a move.
--- This causes the driver to resign the game, since it doesn't have a best move so far.
strategyResign :: Strategy
strategyResign gs cin cout = cout.put (NoMore gs.sid)

--- This strategy selects the first move in the list of moves.
--- Scored 3 times draw by repetition in a 10 games match with fairymax!
strategyFirst :: Strategy
strategyFirst gs cin cout = do
    let m = head (moves gs.current)
    cout.put (MV gs.sid PV{moves=[m], val=0, nodes=1})
    continue ← cin.take
    if continue then cout.put (NoMore gs.sid) else pure ()

--- This strategy selects the best move (indicated by eval), but doesn't consider opponents replies
strategyBest :: Strategy
strategyBest gs cin cout = do
    let ms = moves gs.current
        best = if gs.current.turn == WHITE 
            then head (sortBy (descending (eval gs.history . applyMove gs.current)) ms)
            else head (sortBy (ascending  (eval gs.history . applyMove gs.current)) ms)
    cout.put (MV gs.sid PV{moves=[best], val=0, nodes=1})
    continue ← cin.take
    if continue then cout.put (NoMore gs.sid) else pure ()


strategyMiniMax :: Strategy
strategyMiniMax gs cin cout = do
        let ms = moves gs.current
            best = head ms 
        cout.put (MV gs.sid PV{moves=[best], val=0, nodes=1})
        continue ← cin.take
        if continue 
        then do
            tryMoves cin cout gs (forP gs.current.turn whiteIsMate) (moves gs.current)
        else pure ()
    where
        tryMoves ∷ MVar Command → MVar Input → GameState → Int → [Move] → IO ()
        tryMoves cin cout gs max [] = cout.put (NoMore gs.sid)
        tryMoves cin cout gs max (m:ms) = do
            let pv = miniMax gs.history 2 m
                !better = if gs.current.turn == WHITE then pv.val > max else pv.val < max
            abort ← pure Nothing -- if better then cin.poll else cin.poll       -- make sure it's evaluated
            case abort of
                Just false → println "# strategy aborted" >> stdout.flush
                Just true  → println "# protocol error, got CONTINUE before sending move" >> stdout.flush
                Nothing    →  
                    if better then do
                        cout.put (MV gs.sid pv)
                        continue ← cin.take
                        if continue
                        then tryMoves cin cout gs pv.val ms
                        else pure ()        
                    else tryMoves cin cout gs max ms



miniMax ∷ [Position] → Int → Move → Variation
-- miniMax hist 0 m = PV [m] (eval hist (applyMove (head hist) m)) 1 
miniMax hist n m
    | n == 0 || null ms    = PV [m] (eval hist pos) 1
    | otherwise            = best.{nodes, moves ← (m:)} 
    where
        !pos   = applyMove (head hist) m
        hist'  = pos:hist
        !ms    = moves pos
        pvs    = mapP (miniMax hist' (n-1)) ms 
        nodes  = fold (\n pv -> n + pv.nodes) 0 pvs
        best   = if pos.turn == WHITE
                    then (maximum pvs) 
                    else (minimum pvs)
