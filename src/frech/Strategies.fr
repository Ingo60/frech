--- various Strategies, and a main function that selects one
module frech.Strategies
    inline (upperBound, lowerBound, checkBound, exactScore) 
    where

import frege.control.Concurrent(forkOS, MVar)
import Data.List(sortBy, maximumBy, minimumBy)
import Data.HashMap as HM(lookup, insert, HashMap, values, keys, size)
import Lib.ForkJoin
import Data.Bits(.&., .|., shiftR)

import frech.Protocol
import frech.Eval
import frech.Daten
import frech.FEN(decodeFEN)


-- type Strategy = GameState -> MVar Command -> MVar Input -> IO ()


initialGS = do
    rvar ← MVar.newEmpty
    tvar ← MVar.newEmpty
    ivar ← MVar.newEmpty
    pure GS{history=[initialBoard], state=FORCED, player=BLACK, cores=2, name="unknown", 
            rvar, tvar, ivar, sid=0, best=[], backup=[], nodes=0, plan = Nothing,
            openingMap = empty, killerMoves = empty,
            risk = 100 - atoi (fromMaybe "25" (System.getProperty "frech.risk")),
            tc = TC{myTime=60000, oTime=60000, lvlMoves=40, lvlTime=600000, lvlIncr=5000}} 

main [] = main ["negamax"]            
main [arg] = do
    gs ← initialGS
    forkOS (reader gs.rvar gs.ivar)
    let strategy = case arg of
            'best'      → strategyBest
            'first'     → strategyFirst
            'resign'    → strategyResign
            'minimax'   → strategyMiniMax
            'ab'        → strategyAlphaBeta
            'negamin'   → strategyNegaMax negaSimple
            'nega'      → strategyNegaMax tryNega
            'pvs'       → strategyNegaMax tryPVS
            '(?i)mtdf'  → strategyMTDf
            _           → strategyResign
    let f = File.new "./data"
    c ← f.isDirectory
    unless c do
        f.mkdirs
        pure ()
    hm1 ← initOpeningMap WHITE empty
    hm2 ← initOpeningMap BLACK hm1
    
    protocol strategy gs.{name=arg, openingMap=hm2}
    Concurrent.shutdown
main (arg:args) = main [arg] 

initOpeningMap :: Player -> HashMap Position [Move] -> IO (HashMap Position [Move])
initOpeningMap p hm = do
        let filename = "data/opening-" ++ (show p).toLowerCase
        rdr ← openReader filename
        loopReader filename 1 rdr hm
          `finally` rdr.close
    `catch` (\(some::FileNotFoundException) -> pure hm)

loopReader :: String → Int -> MutableIO BufferedReader → HashMap Position [Move] -> IO (HashMap Position [Move])
loopReader fn !ln rdr hm = do
    line ← rdr.readLine
    case '\s+'.splitted <$> line of
        Just args | [alg, fen1, fen2, fen3, fen4, fen5, fen6] ← args -> 
            case decodeFEN (joined " " (tail args)) of
                Right pos → do
                    let valid = moves pos
                    case unAlgebraic valid alg of
                        Just m → case lookup pos hm of
                            Nothing → loopReader fn (ln+1) rdr (insert pos [m] hm)
                            Just ms
                                | m `notElem` ms → loopReader fn (ln+1) rdr (insert pos (m:ms) hm)
                                | otherwise      → loopReader fn (ln+1) rdr hm    -- duplicate entry?
                        Nothing → do
                            println ("# illegal move " ++ alg ++ " in " ++ fn ++ " line " ++ show ln)
                            loopReader fn (ln+1) rdr hm
                Left msg → do
                    println ("# illegal FEN (" ++ msg ++ ") in "  ++ fn ++ " line " ++ show ln)
                    loopReader fn (ln+1) rdr hm
        Just _ -> do
            println ("# ignoring line " ++ show ln ++ " of file " ++ fn 
                ++ ", it doesn't have 7 space separated fields.")
            loopReader fn (ln+1) rdr hm
        Nothing -> pure hm 
  -- `catch` (\(some::EOFException) → pure hm)

--- a template for new strategies
strategyTemplate ∷ Strategy
strategyTemplate gs  = do
    if true  -- there is a next move
    then do
        m <- pure (mkM WHITE PAWN EMPTY E2 E4)
        -- this could have taken a while, let's see if we got something meanwhile
        continue ← gs.talkPV PV{moves=[m], val=0, nodes=1, depth=1, hash=empty}
        if continue then strategyTemplate gs else pure ()
    else do 
        gs.tellNoMore
        pure ()

--- This strategy doesn't know how to play chess, thus it says it doesn't find a move.
--- This causes the driver to resign the game, since it doesn't have a best move so far.
strategyResign :: Strategy
strategyResign gs = gs.tellNoMore 

--- This strategy selects the first move in the list of moves.
--- Scored 3 times draw by repetition in a 10 games match with fairymax!
strategyFirst :: Strategy
strategyFirst gs = do
    let m = head (orderedMoves gs.current empty (moves gs.current))
    continue ← gs.talkPV  PV{moves=[m], val=0, nodes=1, depth=1, hash=empty}
    if continue then gs.tellNoMore else pure ()

--- This strategy selects the best move (indicated by eval), but doesn't consider opponents replies
strategyBest :: Strategy
strategyBest gs  = do
    let ms = moves gs.current
        best = if gs.current.turn == WHITE 
            then head (sortBy (descending (evalHist gs.history . applyMove gs.current)) ms)
            else head (sortBy (ascending  (evalHist gs.history . applyMove gs.current)) ms)
    continue ← gs.talkPV PV{moves=[best], val=0, nodes=1, depth=1, hash=empty}
    if continue then gs.tellNoMore else pure ()

--- check if higher depth don't give new results 
theEndIsNear ∷ Int → [Variation] → Bool
theEndIsNear depth pvs = all (<depth) (map (length . Variation.moves) pvs)

strategyMiniMax :: Strategy
strategyMiniMax gs  = do
        let allMoves = moves gs.current
        if length allMoves == 1
            then do 
                -- cout.put (MV gs.sid [PV{moves=[head allMoves], val=0, nodes=1}])
                cont ← gs.talkPV PV{moves=[head allMoves], val=9999, nodes=1, depth=1, hash=empty}
                if cont then gs.tellNoMore else pure()
            else tryMoves 2 gs [] allMoves 
    where
        tryMoves ∷ Int →  GameState  → [Variation] → [Move] → IO ()
        tryMoves depth  gs pvs [] = if theEndIsNear depth pvs 
                        then gs.tellNoMore
                        else tryMoves (depth+1)  gs [] (ordered pvs)
            where ordered pvs = map (head • Variation.moves) sorted
                  sorted = if gs.player == WHITE 
                            then sortBy (descending Variation.val) pvs
                            else sortBy (ascending  Variation.val) pvs
        tryMoves depth gs pvs (m:ms) = do
            let !pvraw = miniMax gs.history depth m
                !pv    = correctMateDistance pvraw
            abort ← pure Nothing -- if better then cin.poll else cin.poll       -- make sure it's evaluated
            case abort of
                Just false → println "# strategy aborted" >> stdout.flush
                Just true  → println "# protocol error, got CONTINUE before sending move" >> stdout.flush
                Nothing    →  
                     do
                        continue ← gs.talkPV pv.{depth}
                        if continue 
                            then tryMoves depth  gs (pv:pvs) ms
                            else pure ()        




miniMax ∷ [Position] → Int → Move → Variation
-- miniMax hist 0 m = PV [m] (eval hist (applyMove (head hist) m)) 1 
miniMax !hist !n !m
    | stopThinking              =  PV [m] 0 1 n empty
    | otherwise                 = case moves pos of
        []                      =  let  val = if check 
                                        then if pos.turn == WHITE then whiteIsMate else blackIsMate
                                        else 0 
                                    in PV [m] val 1 n empty
        ms                      = 
          if  pos.getPlyCounter >= 100  then  PV [m] 0 1 n empty
          else if pos `element` hist    then  PV [m] 0 1 n empty
          else if n == 0                then  PV [m] (eval pos) 1 n empty
          else case if n==2 then mapP (miniMax hist' (n-1)) ms 
                    else         map  (miniMax hist' (n-1)) ms of
                pvs                         → best.{nodes, moves ← (m:)}
                    where
                        !nodes  = fold (\n pv -> n + pv.nodes) 0 pvs
                        !best   = case pvs of 
                            (pv:pvs) → if pos.turn == WHITE
                                    then (goMaximum pv pvs) 
                                    else (goMinimum pv pvs)
                            unmöglich → error "miniMax has no moves"
                            
    where
        !pos   = applyMove (head hist) m
        !check = inCheck pos pos.turn
        hist'  = pos:hist


strategyAlphaBeta :: Strategy
strategyAlphaBeta gs  = do
        let allMoves = moves gs.current
        if length allMoves == 1
            then do 
                cont ← gs.talkPV PV{moves=[head allMoves], val=9999, nodes=1, depth=1, hash=empty}
                if cont then gs.tellNoMore else pure()
            else tryMoves 3 whiteIsMate blackIsMate  gs [] allMoves 
    where
        tryMoves ∷ Int → Int → Int → GameState  → [Variation] → [Move] → IO ()
        tryMoves depth alpha beta gs pvs [] = if theEndIsNear depth pvs 
                    then gs.tellNoMore
                    else do
                        gs.tellForget
                        if length goodOnes == 1     -- extraordinary move, like mate
                        then do
                            cont ← gs.talkPVs goodOnes
                            if cont then gs.tellNoMore else pure ()
                        else tryMoves (depth+1) whiteIsMate blackIsMate gs [] (varmoves goodOnes)
            where
                !sorted   = if gs.player == WHITE
                    then sortBy (descending Variation.val) pvs
                    else sortBy (ascending Variation.val) pvs
                !goodOnes = pruned gs.player sorted
                varmoves ∷ [Variation] → [Move]
                varmoves pvs = map (head • Variation.moves) pvs
                relevantWhite r x  = x.val >= r
                relevantBlack r x  = x.val <= r
                pruned ∷ Player → [Variation] → [Variation]
                pruned c pvs
                    | length pvs > 10 = if c == WHITE 
                        then (takeWhile (relevantWhite relevance) pvs)
                        else (takeWhile (relevantBlack relevance) pvs)
                    | otherwise = pvs
                    where
                        !max = maximum  pvs
                        !min = minimum  pvs
                        -- das schlechteste 1/3 soll raus
                        -- weiß: 100 -100 -->  200/3 - 100 = 66 - 100 = -43   (43..100)
                        -- schwarz: 100 -100      
                        !relevance = if c == WHITE 
                                    then (max.val - min.val) `quot` 3 + min.val
                                    else max.val - (max.val - min.val) `quot` 3
                
        tryMoves depth alpha beta gs pvs ms
            --| length ms == 1 = do
            --    cout.put (NoMore gs.sid)
            --    pure ()
            | gs.cores == 1 = do
                let m = head ms
                    pv = correctMateDistance (alphaBeta false gs.history depth alpha beta m)
                    -- alpha' = if gs.player == WHITE then 150 `percent` max alpha pv.val else alpha
                    -- beta'  = if gs.player == BLACK then 150 `percent` min beta  pv.val else beta
                    
                println ("tryAlphaBeta " ++ show depth ++ " " ++  algebraic m)
                stdout.println    
                continue ← gs.talkPV pv.{depth}
                if continue
                then tryMoves depth alpha beta gs (pv:pvs) (tail ms)
                else pure ()
            | otherwise = do
                let !chunk = take gs.cores ms
                    !ms'   = drop gs.cores ms
                    !vs    = mapP (correctMateDistance . alphaBeta false gs.history depth alpha beta) chunk
                println ("tryAlphaBeta " ++ show depth ++ " " ++  display (map algebraic chunk))
                stdout.flush
                let !nodes = fold (+) 0 (map _.nodes vs)    
                when (abs nodes >= 0) stdout.flush 
                continue ← gs.talkPVs vs
                if continue
                then tryMoves depth alpha beta gs (vs++pvs) ms'
                else pure ()


maximize ∷ GameState → Int → Int → Int → [Move] → [Variation]
maximize !gs !d !alpha !beta  []     = []
maximize !gs !d !alpha !beta  (m:ms) = case alphaBeta false gs.history d alpha beta m of
        pv -> pv : maximize gs d alpha' beta' ms where
            alpha' = if gs.player == WHITE then max alpha pv.val else alpha
            beta'  = if gs.player == BLACK then min beta  pv.val else beta

correctMateDistance :: Variation → Variation
correctMateDistance pv =   if pv.val == whiteIsMate then pv.{val = pv.val + dist*2}
                      else if pv.val == blackIsMate then pv.{val = pv.val - dist*2}
                      else pv
      where
        dist = length pv.moves

alphaBeta  ∷ Bool → [Position] → Int → Int → Int → Move → Variation
alphaBeta !extended !hist !d !alpha !beta !m
    | stopThinking              =  PV [m] 0 1 d empty 
    | null ms                   =  let  val = if check 
                                            then if pos.turn == WHITE then whiteIsMate else blackIsMate
                                            else 0 
                                    in PV [m] val 1 d empty
    | pos.getPlyCounter >= 100  = PV [m] 0 1 d empty
    | pos `element` hist        = PV [m] 0 1 d empty
    | d == 0                    = if targt.piece != EMPTY && not extended  
                                    then alphaBeta true hist 1 alpha beta m 
                                    else PV [m] (eval pos) 1 d empty
    | otherwise                 = case alphaBeta extended  hist' (d-1) alpha beta (head ms) of
                                    first → case go extended d pos.turn alpha beta hist' first (tail ms) of
                                        best → PV (m:best.moves) best.val (best.nodes+1) d empty
                                        
    where
        !prev  = head hist
        !targt = whatIsOn prev m.to
        !pos   = applyMove prev m
        !check = inCheck pos pos.turn
        !ms    = moves pos
        hist'  = pos:hist
        
        go ∷ Bool → Int → Player → Int → Int → [Position] → Variation → [Move] → Variation
        go !ext !depth !player !alpha !beta !hist !best [] = best
        go !ext !depth !player !alpha !beta !hist !best (!m:ms)
            -- better pos.turn best beta = best
            | player == WHITE = 
                if best.val >= beta then best
                else case alphaBeta ext hist (depth-1) best.val beta m of
                    next → go ext depth player best.val beta  hist (max best next).{nodes = best.nodes + next.nodes} ms
                
            | otherwise =
                if best.val <= alpha then best
                else case alphaBeta ext hist (depth-1) alpha best.val m of 
                    next → go ext depth  player alpha best.val  hist  (min best next).{nodes = best.nodes + next.nodes} ms

--- a 'Variation' that must be replaced by any other in the 'negaMax' loop (even by mate)
!noPV = PV [] (whiteIsMate*2) 0 0 empty

negaMax :: GameState → TranspositionTable → Bool → Int → Int → Int → Variation
negaMax !gs !transp !extended !depth !alpha !beta
    | stopThinking              =  PV [] 0 1 depth transp 
    | pos.getPlyCounter >= 100  =  PV [] 0 1 depth transp
    | pos `element` tail gs.history  = PV [] 0 1 depth transp
    | depth == 0                = PV [] (pos.turn.factor * eval pos) 1 depth transp
    | otherwise                 =
        case lookup pos transp of
            Just te =  
                        case checkBound te.score of
                            EQ | te.depth >= depth 
                               = PV{moves=te.pvMoves, val=te.score `shiftR` 2, nodes=0, depth, hash=transp}
                            LT | te.depth >= depth = if alpha' >= beta
                                    then PV{moves=te.pvMoves, val=alpha', nodes=0, depth, hash=transp} 
                                    else case ordered of
                                      (_:_) → case go gs' transp extended depth alpha' beta noPV ordered of
                                        !pv | depth >= te.depth, not extended = insertPV pos depth alpha beta pv ordered
                                            | otherwise = pv
                                      []  | inCheck pos pos.turn          = PV [] whiteIsMate 1 depth transp
                                          | otherwise                     = PV [] 0           1 depth transp
                               where alpha' = max alpha ((te.score-1) `shiftR` 2)
                            GT | te.depth >= depth = if alpha >= beta'
                                    then  PV{moves=te.pvMoves, val=beta', nodes=0, depth, hash=transp}
                                    else  case ordered of 
                                      (_:_) → case go gs' transp extended depth alpha beta' noPV te.posMoves of
                                        !pv | depth >= te.depth, not extended = insertPV pos depth alpha beta' pv ordered
                                            | otherwise = pv
                                      []  | inCheck pos pos.turn          = PV [] whiteIsMate 1 depth transp
                                          | otherwise                     = PV [] 0           1 depth transp
                               where beta' = min beta ((te.score+1) `shiftR` 2)
                            sonst =  case ordered of 
                              (_:_) → case go gs' transp extended depth alpha beta noPV te.posMoves of
                                !pv → if extended then pv else insertPV pos depth alpha beta pv ordered
                              []  | inCheck pos pos.turn          = PV [] whiteIsMate 1 depth transp
                                  | otherwise                     = PV [] 0           1 depth transp
                    where
                        !hashmove = head te.pvMoves
                        !ordered = hashmove : [ m | m ← te.posMoves, m!=hashmove ]
                        !gs' = gs.{killerMoves = insert hashmove 5 gs.killerMoves} 
                    
            Nothing →  case fromMaybe (oms gs pos depth) (lookup pos gs.openingMap) of
                !ms@(_:_) → case go gs transp extended depth alpha beta noPV ms of
                        !pv = if extended then pv else insertPV pos depth alpha beta pv ms
                []
                    | inCheck pos pos.turn          = PV [] whiteIsMate 1 depth transp
                    | otherwise                     = PV [] 0           1 depth transp
    where
        !pos   = gs.current
        -- ms    = moves pos
        -- check = inCheck pos pos.turn
        insertPV ∷ Position → Int → Int → Int → Variation → [Move] → Variation
        insertPV !pos depth !alpha !beta !pv !ms = case TR{depth, score=bound, pvMoves=pv.moves, posMoves=ms}
                of tr | pv.val != 0 = pv.{hash = insert pos tr pv.hash}
                      | otherwise   = pv
            where 
                !bound = if pv.val >= beta then lowerBound pv.val
                            else if pv.val >= alpha then exactScore pv.val
                            else upperBound pv.val
        
        oms ∷ GameState → Position → Int → [Move]
        oms gs pos depth = if depth > 1 then orderedMoves pos gs.killerMoves (moves pos) else moves pos
        
        go ∷ GameState → TranspositionTable → Bool → Int → Int → Int → Variation → [Move] → Variation
        go !gs !transp !ext !depth !alpha !beta !best [] = best
        go !gs !transp !ext !depth !alpha !beta !best (m:ms)
            --| depth == 2 = case mapP (moveNega gs alpha beta) (m:ms) of
            --    (pv:pvs) -> maxNega 1 beta pv pvs 
            | otherwise 
            = case applyMove gs.current m of
                !pos → case negaMax gs.{history=pos!:gs.history} transp capture d (-beta) (-alpha) of
                  !pv → case negate pv.val of
                    !score
                        | false, gs.current.getRootDistance == 1,
                          traceLn diag = best
                        | otherwise = if score >= beta then killerpv 
                            else if (score > alpha || score > best.val)
                                then go gs' pv.hash ext depth (max score alpha) beta cpv ms
                                else go gs' pv.hash ext depth alpha beta best' ms
                        where
                            gs' = if null pv.moves then gs 
                                    else gs.{killerMoves = insert (head pv.moves) 2 gs.killerMoves}
                            killerpv = pv.{nodes=best.nodes+pv.nodes,moves=m.makeKiller!:pv.moves,val=score}
                            cpv = pv.{nodes=best.nodes+pv.nodes,moves=m!:pv.moves,val=score}
                            best' = best.{nodes=best.nodes+pv.nodes, hash=pv.hash}
                            diag = "# goN alpha=" ++ show alpha ++ ", beta=" ++ show beta
                                ++ ", score=" ++ show score ++ (if score > alpha then "!" else " ")
                                ++ (if score >= beta then "!" else "")
                                ++ (if score <= pv.val then "?" else "")
                                ++ " candidate=" ++ joined " "  (map algebraic cpv.moves)
                  where
                    capture = not ext && depth == 1 &&  (not (gs.current.empty m.to) || inCheck pos pos.turn) 
                    d = if capture then depth else depth-1 

moveNega ∷ GameState → Int → Int → Move → Variation
moveNega gs alpha beta m = case applyMove gs.current m of
    !pos → case negaMax gs.{history=pos:gs.history} empty false 1 (-beta) (-alpha) of
        !pv → pv.{val = negate pv.val, moves=m:pv.moves}

maxNega ∷ Int → Int → Variation → [Variation] → Variation
maxNega acc beta pv [] = pv.{nodes=pv.nodes+acc}
maxNega acc beta pv (cpv:pvs)
    | pv.val >= beta   = pv.{nodes=pv.nodes+acc}
    | cpv.val > pv.val = maxNega (acc+pv.nodes)  beta cpv pvs
    | otherwise        = maxNega (acc+cpv.nodes) beta  pv pvs 

--- create a lower bound score
lowerBound ∷ Int → Int
lowerBound !n = 4*n+1

--- create an upper bound score 
upperBound ∷ Int → Int
upperBound !n = 4*n-1

--- create an exact score
exactScore n = n*4

checkBound n =
    if  n .&. 3 == 0            then EQ     -- exact
    else if (n-1) .&. 3 == 0    then LT     -- lower bound
    else                             GT     -- upper bound



expectedMoves :: GameState → Maybe [Move]
expectedMoves gs 
    | odd pos.getRootDistance = lookup pos gs.openingMap
    | otherwise = Nothing 
    where 
        pos = gs.current

moveRating ∷ Position → HashMap Move Int → Move → Int
moveRating pos hash mv = killer + goodCapturing + moveHanging + checking + attacking + badCapturing + castling + pawnMove
    where
        rpos = applyMove pos mv
        -- rmoves = moves rpos
        source = whatIsOn pos mv.from
        -- target = whatIsOn pos mv.to
        after  = whatIsOn rpos mv.to
        vt = pieceValue (pos.on (singleton mv.to))
        killer        = fromMaybe 0 (hash.lookup mv)
        goodCapturing = if  pieceValue mv.piece < vt-10             then 9  else 0
        castling      = if  mv.piece == KING && mv.promote != EMPTY then 3  else 0
        checking      = if  inCheck rpos rpos.turn                  then 1  else 0
        attacking     = card (pieceTargets source `inter` pos.playerFigures mv.player.opponent)
                            - card (pieceTargets after `inter` rpos.playerFigures mv.player.opponent)  
        badCapturing  = if vt > 0                                   then 1  else 0 
        pawnMove      = if endgame rpos && mv.piece == PAWN 
                            then if mv.promote > EMPTY then 10 else 5 
                            else 0
        -- if the piece is taken elsewhere, it costs less
        moveHanging   = if scoreHanging pos mv.from < scoreHanging rpos mv.to then 5 else 0 

orderedMoves ∷ Position → HashMap Move Int → [Move] → [Move]
orderedMoves !pos !hash !ms = map fst (sortBy (descending snd) (zip ms (map (moveRating pos hash) ms))) 


type NegaMaxWorker = GameState → TranspositionTable → Int → Int → Int →  [Variation] → [Move] → IO ()

strategyNegaMax ∷ NegaMaxWorker → Strategy
strategyNegaMax tryNega gs  = do
        let suggested = fold (\h\m → insert m 2 h) empty (fromMaybe [] (lookup gs.current gs.openingMap)) 
            allMoves = orderedMoves gs.current suggested (moves gs.current)
        println "# in strategyNegaMax"
        stdout.flush
        if length allMoves == 1
            then do 
                cont ← gs.talkPV PV{moves=[head allMoves], val=gs.player.factor*(-9999), nodes=1, depth=1, hash=empty}
                if cont then gs.tellNoMore else pure()
            else  case gs.plan of
                Just (plan@PV{depth,val,moves=_:_:planmv:_}) 
                    | blackIsMate - val*gs.player.factor < 100 = do
                        println ("# We have a mate plan: " ++ show plan)
                        stdout.flush
                        cont1 ← gs.talkPV plan.{depth ← subtract 2, moves ← drop 2, nodes = 1}
                        if not cont1 then pure () else gs.tellNoMore
                Just (plan@PV{depth,val,moves=_:_:planmv:_}) | val * gs.player.factor > 25 = do
                        println ("# We have a plan: " ++ show plan)
                        stdout.flush
                        cont1 ← gs.talkPV plan.{depth ← subtract 2, moves ← drop 2, nodes = 1}
                        if not cont1 then pure ()
                        else do
                            gs.tellForget
                            let pos = applyMove gs.current planmv
                                pv' = correctMateDistance (negaMax gs.{history=pos:gs.history} plan.hash
                                                            false (depth-1) whiteIsMate blackIsMate)
                                pv = pv'.{moves=planmv:pv'.moves, val ← (* pos.turn.factor), depth}
                            println ("# Plan continuation: " ++ show pv)
                            cont ← gs.talkPV pv
                            if gs.player.factor * pv.val > 95 `percent` gs.player.factor * val
                                &&    (gs.player.factor * pv.val == blackIsMate         -- direct mate
                                    || gs.player.factor * pv.val <  blackIsMate - 100)  -- look for shortest path anyway   
                            then do
                                gs.tellNoMore
                            else do
                                println("# We better look for another plan.")
                                stdout.flush
                                if cont 
                                    then tryNega gs pv.hash depth whiteIsMate blackIsMate  [pv] 
                                            (filter (!= planmv) allMoves)
                                    else pure ()
                other → do
                    println("# no plan")
                    stdout.flush
                    tryNega gs empty 4 whiteIsMate blackIsMate  [] allMoves

negaSimple :: NegaMaxWorker
negaSimple gs hash depth alpha beta _ _ 
    | stopThinking = gs.tellNoMore
    | otherwise = do
    let !pv' = correctMateDistance (negaMax gs hash false (depth) (-beta) (-alpha))
        !pv = pv'.{val ← (* gs.player.factor)} 
    gs.tellForget
    continue ← gs.talkPV pv.{depth}
    if continue
        then if length pv.moves + 1 < depth 
                || pv.val < whiteIsMate + 10  
                || pv.val > blackIsMate + 10
                || pv.val == 0
            then gs.tellNoMore
            else negaSimple gs hash (depth + 1) alpha beta [] []
        else pure ()
     
tryNega ∷ NegaMaxWorker
tryNega gs hash depth alpha beta pvs [] = if theEndIsNear depth pvs 
            then gs.tellNoMore
            else do
                gs.tellForget
                tryNega gs hash (depth+1) whiteIsMate blackIsMate [] (varmoves goodOnes)
    where
        !sorted   = if gs.player == WHITE
            then sortBy (descending Variation.val) pvs
            else sortBy (ascending Variation.val) pvs
        !goodOnes = {- pruned gs.player -} sorted
        varmoves ∷ [Variation] → [Move]
        varmoves pvs = map (head • Variation.moves) pvs
        
tryNega gs hash depth alpha beta pvs ms
    | stopThinking = pure ()
    | alpha >= beta = gs.tellNoMore
    | otherwise = do
        let m = head ms
        println ("# tryNegaMax "          ++ show depth 
                        ++ "  checking: " ++ show m
                        ++ "  killers: "  ++ show (keys gs.killerMoves))
        stdout.flush
        let pos = applyMove gs.current m
            pv' = correctMateDistance (negaMax gs.{history=pos:gs.history} hash false (depth-1) (-beta) (-alpha))
            pv = pv'.{moves=m:pv'.moves, val ← (* pos.turn.factor)}
            score = negate pv'.val
            -- alpha' =  max alpha score
            newKillers = fold (\h\m → h.insert m 2) gs.killerMoves 
                            [ m.clearKiller | m ← pv.moves, m.killer ]
            killerHash kh = case pv.moves of
                (_:k:_) → insert k 1 kh 
                _       → kh
            
            
        println ("# tryNegaMax " ++ show depth ++ " alpha=" ++  show alpha
             ++ " beta=" ++  show beta
             ++ " move=" ++ algebraic m ++ " score=" ++ show score)
        let vs = values pv.hash
        println ("# tryNegaMax " ++ show depth 
                    ++ " hash size=" ++ show (length vs) 
                    -- " used entries=" ++ show (length [ te | te <- vs, te.useful > 0])
                    -- " total uses=" ++ show (fold (\acc te -> acc + te.useful) 0 vs)
                    )
        stdout.flush
        continue ← gs.talkPV pv.{depth} 
        if continue
        then tryNega gs.{killerMoves=killerHash newKillers} pv.hash depth alpha beta (pv:pvs) (tail ms)
        else pure ()

strategyMTDf :: Strategy
strategyMTDf gs  = do
        let suggested = fold (\h\m → insert m 2 h) empty (fromMaybe [] (lookup gs.current gs.openingMap)) 
            allMoves = orderedMoves gs.current suggested (moves gs.current)
        println "# in strategyMTDf"
        stdout.flush
        if length allMoves == 1
            then do 
                cont ← gs.talkPV PV{moves=[head allMoves], val=gs.player.factor*(-9999), nodes=1, depth=1, hash=empty}
                if cont then gs.tellNoMore else pure()
            
            else do
                println ("# our MTDf plan: " ++ show gs.plan)     
                case gs.plan of
                    Just (plan@PV{depth,val,moves=_:_:planmv:_}) 
                        | blackIsMate - val*gs.player.factor < 100 = do
                            println ("# We have a mate plan: " ++ show plan)
                            stdout.flush
                            cont1 ← gs.talkPV plan.{depth ← subtract 2, moves ← drop 2, nodes = 1}
                            if not cont1 then pure () else gs.tellNoMore
                    Just plan → do
                        println "# let's see whether we can continue"
                        stdout.flush
                        tryMTDf gs plan.hash 4 [] allMoves
                    other → do
                        println("# no plan at all")
                        stdout.flush
                        tryMTDf gs empty 4 [] allMoves


tryMTDf ∷ GameState → TranspositionTable → Int →  [Variation] → [Move] → IO ()
tryMTDf gs hash  depth pvs [] = if theEndIsNear depth pvs 
            then gs.tellNoMore
            else do
                gs.tellForget
                println ("# risk=" ++ show gs.risk ++ "%, dropped pvs: " ++ show (dropped sorted))
                tryMTDf gs hash (depth+1) [] (varmoves goodOnes)
    where
        !sorted   = if gs.player == WHITE
            then sortBy (descending Variation.val) pvs
            else sortBy (ascending Variation.val) pvs
        !goodOnes = takeBest 0 sorted
        varmoves ∷ [Variation] → [Move]
        varmoves pvs = map (head • Variation.moves) pvs
        min = if null pvs then 0 else minimum (map (\p → p.val*gs.player.factor) pvs)
        pvns = map (\x → x.val * gs.player.factor - min + 1) pvs
        risk  = if inCheck gs.current gs.player || length pvs < 10 then 100 else gs.risk
        limit = risk `percent` sum pvns
        takeBest n []   = []
        takeBest n (x:xs) 
            | n > limit = []
            | otherwise = x : takeBest (n+ x.val * gs.player.factor - min + 1) xs
        dropped = map algebraic . map head . map _.moves . drop (length goodOnes) 

tryMTDf gs hash depth [] [m] = do
    println "# only a single move left"
    cont ← gs.talkPV PV{moves=[m], val=0, nodes=1, depth, hash=empty}
    if cont then gs.tellNoMore else pure()        
        
tryMTDf gs hash depth pvs ms
    | stopThinking = pure ()
    | otherwise = do
        let m = head ms
        println ("# tryMTDf "          ++ show depth 
                        ++ "  checking: " ++ show m
                        ++ "  killers: "  ++ show (keys gs.killerMoves))
        stdout.flush
        let pos = applyMove gs.current m
            pv' = mtLoop gs.{history=pos:gs.history} hash 0 depth whiteIsMate blackIsMate
            pv = pv'.{moves=m:pv'.moves, val ← (* pos.turn.factor)}
            score = negate pv'.val
            -- alpha' =  max alpha score
            newKillers = fold (\h\m → h.insert m 2) gs.killerMoves 
                            [ m.clearKiller | m ← pv.moves, m.killer ]
            killerHash kh = case pv.moves of
                (_:k:_) → insert k 1 kh 
                _       → kh
            
            
        println ("# tryMTDf " ++ show depth  
             ++ " move=" ++ algebraic m ++ " score=" ++ show score)
        -- let vs = values pv.hash
        println ("# tryMTDf " ++ show depth 
                    ++ " hash size=" ++ show (size pv.hash) 
                    -- " used entries=" ++ show (length [ te | te <- vs, te.useful > 0])
                    -- " total uses=" ++ show (fold (\acc te -> acc + te.useful) 0 vs)
                    )
        stdout.flush
        continue ← gs.talkPV pv.{depth} 
        if continue
        then tryMTDf gs.{killerMoves=killerHash newKillers} pv.hash depth (pv:pvs) (tail ms)
        else pure ()


mtLoop :: GameState → TranspositionTable → Int → Int → Int → Int → Variation
mtLoop !gs !transp !nodes !d !lower !upper
    -- traceLn ("# mtLoop d=%d beta=%d lower=%d upper=%d".format d beta lower upper) = noPV
    | otherwise = 
        case correctMateDistance (negaMax gs transp false d (beta-1) beta)
            of !pv  | lower' >= upper' = pv.{nodes = nodes+pv.nodes}
                    | otherwise = mtLoop gs pv.hash (nodes+pv.nodes) d  lower' upper'
                    where
                        upper' = if pv.val <  beta  then pv.val else upper
                        lower' = if pv.val >= beta  then pv.val else lower    
    where 
        !beta = avg + (avg .&. 1)
        !avg  = (upper + lower) `quot` 2


tryPVS :: NegaMaxWorker
tryPVS gs hash depth alpha nodes pvs [] = if theEndIsNear depth pvs 
            then gs.tellNoMore
            else do
                gs.tellForget
                tryPVS gs hash (depth+1) whiteIsMate 0 [] (varmoves goodOnes)
    where
        !sorted   = if gs.player == WHITE
            then sortBy (descending Variation.val) pvs
            else sortBy (ascending Variation.val) pvs
        !goodOnes = {- pruned gs.player -} sorted
        varmoves ∷ [Variation] → [Move]
        varmoves pvs = map (head • Variation.moves) pvs
        
tryPVS gs hash depth alpha nodes pvs ms
    | stopThinking = pure ()
    | otherwise = do
        let m = head ms
        println ("# tryPVS "          ++ show depth 
                        ++ "  checking: " ++ show m
                        ++ "  killers: "  ++ show (keys gs.killerMoves))
        stdout.flush
        let first = null pvs
            pos = applyMove gs.current m
            pv' = if first
                then correctMateDistance (negaMax gs.{history=pos:gs.history} hash false (depth-1) whiteIsMate blackIsMate)
                else correctMateDistance (negaMax gs.{history=pos:gs.history} hash false (depth-1) (-alpha) (1-alpha))
            pv = pv'.{moves=m:pv'.moves, val ← (* pos.turn.factor)}
            score = negate pv'.val
            alpha' =  max alpha score
            newKillers = fold (\h\m → h.insert m 2) gs.killerMoves 
                            [ m.clearKiller | m ← pv.moves, m.killer ]
            killerHash kh = case pv.moves of
                (_:k:_) → insert k 1 kh 
                _       → kh
            
            
        println ("# tryPVS " ++ show depth ++ " alpha=" ++  show alpha
             ++ " first=" ++  show first
             ++ " move=" ++ algebraic m ++ " score=" ++ show score)
        println ("# tryPVS " ++ show depth 
                    ++ " hash size=" ++ show (size pv.hash) 
                )
        stdout.flush
        
        if first then do
                continue ← gs.talkPV pv.{depth} 
                if continue
                then tryPVS gs.{killerMoves=killerHash newKillers} pv.hash depth alpha' 0 (pv:pvs) (tail ms)
                else pure ()        
        else if score <= alpha then do
                tryPVS gs.{killerMoves=killerHash newKillers} pv.hash depth alpha' (nodes+pv.nodes) (pv:pvs) (tail ms)
        else do
            let pv'' = correctMateDistance (negaMax gs.{history=pos:gs.history} pv.hash false (depth-1) whiteIsMate blackIsMate)
                pv2 = pv''.{moves=m:pv''.moves, val ← (* pos.turn.factor), nodes ← (+nodes)}
                score = negate pv''.val
                alpha' =  max alpha score
                newKillers = fold (\h\m → h.insert m 2) gs.killerMoves 
                            [ m.clearKiller | m ← pv.moves, m.killer ]
                killerHash kh = case pv.moves of
                    (_:k:_) → insert k 1 kh 
                    _       → kh

            println ("# tryPVS RE-SEARCH " ++ show depth ++ " alpha=" ++  show alpha
                 ++ " first=" ++  show first
                 ++ " move=" ++ algebraic m ++ " score=" ++ show score)
            println ("# tryPVS " ++ show depth 
                    ++ " hash size=" ++ show (size pv.hash) 
                )
            stdout.flush

            continue ← gs.talkPV pv2.{depth} 
            if continue
            then tryPVS gs.{killerMoves=killerHash newKillers} pv2.hash depth alpha' 0 (pv2:pvs) (tail ms)
            else pure ()