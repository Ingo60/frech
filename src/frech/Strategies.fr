--- various Strategies, and a main function that selects one
module frech.Strategies where

import frege.control.Concurrent(forkOS, MVar)
import Data.List(sortBy)
import Lib.ForkJoin

import frech.Protocol
import frech.Eval
import frech.Daten

-- type Strategy = GameState -> MVar Command -> MVar Input -> IO ()


initialGS = do
    rvar ← MVar.newEmpty
    tvar ← MVar.newEmpty
    ivar ← MVar.newEmpty
    pure GS{history=[initialBoard], state=FORCED, player=BLACK, 
            rvar, tvar, ivar, sid=0, pings=[], best=Nothing, myTime=60000, oTime = 60000} 

main [] = main ["best"]            
main [arg] = do
    gs ← initialGS
    forkOS (reader gs.rvar gs.ivar)
    let strategy = case arg of
            "best"      → strategyBest
            "first"     → strategyFirst
            "resign"    → strategyResign
            "minimax"   → strategyMiniMax
            _           → strategyBest   
    protocol strategy gs
    Concurrent.shutdown
main (arg:args) = main [arg] 
     
--- a template for new strategies
strategyTemplate ∷ Strategy
strategyTemplate gs cin cout = do
    if true  -- there is a next move
    then do
        m <- pure M{player=WHITE, piece=PAWN, promote=EMPTY, from=E2, to=E4}
        -- this could have taken a while, let's see if we got something meanwhile
        abort ← cin.poll
        case abort of
            Just false → pure ()   -- abort
            Just true  → println "# protocol error, got CONTINUE before sending move" >> stdout.flush
            Nothing    → do 
                cout.put (MV gs.sid PV{moves=[m], val=0, nodes=1})
                continue <- cin.take
                if continue then strategyTemplate gs cin cout else pure ()
    else do 
        cout.put (NoMore gs.sid)
        pure ()

--- This strategy doesn't know how to play chess, thus it says it doesn't find a move.
--- This causes the driver to resign the game, since it doesn't have a best move so far.
strategyResign :: Strategy
strategyResign gs cin cout = cout.put (NoMore gs.sid)

--- This strategy selects the first move in the list of moves.
--- Scored 3 times draw by repetition in a 10 games match with fairymax!
strategyFirst :: Strategy
strategyFirst gs cin cout = do
    let m = head (moves gs.current)
    cout.put (MV gs.sid PV{moves=[m], val=0, nodes=1})
    continue ← cin.take
    if continue then cout.put (NoMore gs.sid) else pure ()

--- This strategy selects the best move (indicated by eval), but doesn't consider opponents replies
strategyBest :: Strategy
strategyBest gs cin cout = do
    let ms = moves gs.current
        best = if gs.current.turn == WHITE 
            then head (sortBy (descending (evalHist gs.history . applyMove gs.current)) ms)
            else head (sortBy (ascending  (evalHist gs.history . applyMove gs.current)) ms)
    cout.put (MV gs.sid PV{moves=[best], val=0, nodes=1})
    continue ← cin.take
    if continue then cout.put (NoMore gs.sid) else pure ()


strategyMiniMax :: Strategy
strategyMiniMax gs cin cout = do
        let allMoves = moves gs.current
        if length allMoves == 1
            then do 
                cout.put (MV gs.sid PV{moves=[head allMoves], val=0, nodes=1})
                cont ← cin.take
                if cont then cout.put (NoMore gs.sid) else pure()
            else tryMoves 2 cin cout gs [] allMoves 
    where
        tryMoves ∷ Int → MVar Command → MVar Input → GameState  → [Variation] → [Move] → IO ()
        tryMoves depth cin cout gs pvs [] = tryMoves (depth+1) cin cout gs [] (ordered pvs)
            where ordered pvs = map (head • Variation.moves) sorted
                  sorted = if gs.player == WHITE 
                            then sortBy (descending Variation.val) pvs
                            else sortBy (ascending  Variation.val) pvs
        tryMoves depth cin cout gs pvs (m:ms) = do
            let !pvraw = miniMax gs.history depth m
                !pvms  = length pvraw.moves * 100 - 1
                !pv = if pvraw.val == whiteIsMate then pvraw.{val ← (+pvms)}
                      else if pvraw.val == blackIsMate then pvraw.{val ← subtract pvms}
                      else pvraw
            abort ← pure Nothing -- if better then cin.poll else cin.poll       -- make sure it's evaluated
            case abort of
                Just false → println "# strategy aborted" >> stdout.flush
                Just true  → println "# protocol error, got CONTINUE before sending move" >> stdout.flush
                Nothing    →  
                     do
                        cout.put $! (MV gs.sid pv)
                        continue ← cin.take
                        if continue
                        then tryMoves depth cin cout gs (pv:pvs) ms
                        else pure ()        




miniMax ∷ [Position] → Int → Move → Variation
-- miniMax hist 0 m = PV [m] (eval hist (applyMove (head hist) m)) 1 
miniMax hist n m
    | null ms              =  let  val = if check 
                                    then if pos.turn == WHITE then whiteIsMate else blackIsMate
                                    else 0 
                                in PV [m] val 1
    | pos.getPlyCounter >= 100  = PV [m] 0 1
    | pos `element` hist        = PV [m] 0 1
    | n == 0                    = PV [m] (eval pos ms) 1
    | otherwise                 = best.{nodes, moves ← (m:)} 
    where
        !pos   = applyMove (head hist) m
        !check = inCheck pos pos.turn
        !ms    = moves pos
        hist'  = pos:hist
        pvs    = if n==2 then mapP (miniMax hist' (n-1)) ms else map (miniMax hist' (n-1)) ms 
        nodes  = fold (\n pv -> n + pv.nodes) 0 pvs
        best   = case pvs of 
            (pv:pvs) → if pos.turn == WHITE
                    then (goMaximum pv pvs) 
                    else (goMinimum pv pvs)
            unmöglich → error "miniMax has no moves"
        goMaximum, goMinimum ∷ Variation → [Variation] → Variation
        goMaximum !best (pv:pvs) = goMaximum (max best pv) pvs
        goMaximum !best []       = best 
        goMinimum !best (pv:pvs) = goMinimum (min best pv) pvs
        goMinimum !best []       = best 
