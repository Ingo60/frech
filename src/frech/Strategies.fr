--- various Strategies, and a main function that selects one
module frech.Strategies where

import frege.control.Concurrent(forkOS, MVar)
import Data.List(sortBy, maximumBy, minimumBy)
import Data.HashMap as HM(lookup, insert, HashMap)
import Lib.ForkJoin

import frech.Protocol
import frech.Eval
import frech.Daten
import frech.FEN(decodeFEN)

-- type Strategy = GameState -> MVar Command -> MVar Input -> IO ()


initialGS = do
    rvar ← MVar.newEmpty
    tvar ← MVar.newEmpty
    ivar ← MVar.newEmpty
    pure GS{history=[initialBoard], state=FORCED, player=BLACK, cores=2, name="unknown", 
            rvar, tvar, ivar, sid=0, best=[], backup=[], expected = Nothing,
            openingMap = empty, killerMoves = empty,
            tc = TC{myTime=60000, oTime=60000, lvlMoves=40, lvlTime=600000, lvlIncr=5000}} 

main [] = main ["best"]            
main [arg] = do
    gs ← initialGS
    forkOS (reader gs.rvar gs.ivar)
    let strategy = case arg of
            "best"      → strategyBest
            "first"     → strategyFirst
            "resign"    → strategyResign
            "minimax"   → strategyMiniMax
            "ab"        → strategyAlphaBeta
            "negamax"   → strategyNegaMax
            _           → strategyResign
    let f = File.new "./data"
    c ← f.isDirectory
    unless c do
        f.mkdirs
        pure ()
    hm1 ← initOpeningMap WHITE empty
    hm2 ← initOpeningMap BLACK hm1
    
    protocol strategy gs.{name=arg, openingMap=hm2}
    Concurrent.shutdown
main (arg:args) = main [arg] 

initOpeningMap :: Player -> HashMap Position [Move] -> IO (HashMap Position [Move])
initOpeningMap p hm = do
        let filename = "data/opening-" ++ (show p).toLowerCase
        rdr ← openReader filename
        loopReader filename 1 rdr hm
          `finally` rdr.close
    `catch` (\(some::FileNotFoundException) -> pure hm)

loopReader :: String → Int -> MutableIO BufferedReader → HashMap Position [Move] -> IO (HashMap Position [Move])
loopReader fn !ln rdr hm = do
    line ← rdr.getLine
    case '\s+'.splitted line of
        args@[alg, fen1, fen2, fen3, fen4, fen5, fen6] -> 
            case decodeFEN (joined " " (tail args)) of
                Right pos → do
                    let valid = moves pos
                    case unAlgebraic valid alg of
                        Just m → case lookup pos hm of
                            Nothing → loopReader fn (ln+1) rdr (insert pos [m] hm)
                            Just ms
                                | m `notElem` ms → loopReader fn (ln+1) rdr (insert pos (m:ms) hm)
                                | otherwise      → loopReader fn (ln+1) rdr hm    -- duplicate entry?
                        Nothing → do
                            println ("# illegal move " ++ alg ++ " in " ++ fn ++ " line " ++ show ln)
                            loopReader fn (ln+1) rdr hm
                Left msg → do
                    println ("# illegal FEN (" ++ msg ++ ") in "  ++ fn ++ " line " ++ show ln)
                    loopReader fn (ln+1) rdr hm
        _ -> do
            println ("# ignoring line " ++ show ln ++ " of file " ++ fn 
                ++ ", it doesn't have 7 space separated fields.")
            loopReader fn (ln+1) rdr hm 
  `catch` (\(some::EOFException) → pure hm)

--- a template for new strategies
strategyTemplate ∷ Strategy
strategyTemplate gs  = do
    if true  -- there is a next move
    then do
        m <- pure (mkM WHITE PAWN EMPTY E2 E4)
        -- this could have taken a while, let's see if we got something meanwhile
        continue ← gs.talkPV PV{moves=[m], val=0, nodes=1}
        if continue then strategyTemplate gs else pure ()
    else do 
        gs.tellNoMore
        pure ()

--- This strategy doesn't know how to play chess, thus it says it doesn't find a move.
--- This causes the driver to resign the game, since it doesn't have a best move so far.
strategyResign :: Strategy
strategyResign gs = gs.tellNoMore 

--- This strategy selects the first move in the list of moves.
--- Scored 3 times draw by repetition in a 10 games match with fairymax!
strategyFirst :: Strategy
strategyFirst gs = do
    let m = head (moves gs.current)
    continue ← gs.talkPV  PV{moves=[m], val=0, nodes=1}
    if continue then gs.tellNoMore else pure ()

--- This strategy selects the best move (indicated by eval), but doesn't consider opponents replies
strategyBest :: Strategy
strategyBest gs  = do
    let ms = moves gs.current
        best = if gs.current.turn == WHITE 
            then head (sortBy (descending (evalHist gs.history . applyMove gs.current)) ms)
            else head (sortBy (ascending  (evalHist gs.history . applyMove gs.current)) ms)
    continue ← gs.talkPV PV{moves=[best], val=0, nodes=1}
    if continue then gs.tellNoMore else pure ()

--- check if higher depth don't give new results 
theEndIsNear ∷ Int → [Variation] → Bool
theEndIsNear depth pvs = all (<depth) (map (length . Variation.moves) pvs)

strategyMiniMax :: Strategy
strategyMiniMax gs  = do
        let allMoves = moves gs.current
        if length allMoves == 1
            then do 
                -- cout.put (MV gs.sid [PV{moves=[head allMoves], val=0, nodes=1}])
                cont ← gs.talkPV PV{moves=[head allMoves], val=0, nodes=1}
                if cont then gs.tellNoMore else pure()
            else tryMoves 2 gs [] allMoves 
    where
        tryMoves ∷ Int →  GameState  → [Variation] → [Move] → IO ()
        tryMoves depth  gs pvs [] = if theEndIsNear depth pvs 
                        then gs.tellNoMore
                        else tryMoves (depth+1)  gs [] (ordered pvs)
            where ordered pvs = map (head • Variation.moves) sorted
                  sorted = if gs.player == WHITE 
                            then sortBy (descending Variation.val) pvs
                            else sortBy (ascending  Variation.val) pvs
        tryMoves depth gs pvs (m:ms) = do
            let !pvraw = miniMax gs.history depth m
                !pv = correctMateDistance pvraw
            abort ← pure Nothing -- if better then cin.poll else cin.poll       -- make sure it's evaluated
            case abort of
                Just false → println "# strategy aborted" >> stdout.flush
                Just true  → println "# protocol error, got CONTINUE before sending move" >> stdout.flush
                Nothing    →  
                     do
                        continue ← gs.talkPV pv
                        if continue 
                            then tryMoves depth  gs (pv:pvs) ms
                            else pure ()        




miniMax ∷ [Position] → Int → Move → Variation
-- miniMax hist 0 m = PV [m] (eval hist (applyMove (head hist) m)) 1 
miniMax !hist !n !m
    | stopThinking              =  PV [m] 0 1
    | otherwise                 = case moves pos of
        []                      =  let  val = if check 
                                        then if pos.turn == WHITE then whiteIsMate else blackIsMate
                                        else 0 
                                    in PV [m] val 1
        ms                      = 
          if  pos.getPlyCounter >= 100  then  PV [m] 0 1
          else if pos `element` hist    then  PV [m] 0 1
          else if n == 0                then  PV [m] (eval pos) 1
          else case if n==2 then mapP (miniMax hist' (n-1)) ms 
                    else         map  (miniMax hist' (n-1)) ms of
                pvs                         → best.{nodes, moves ← (m:)}
                    where
                        !nodes  = fold (\n pv -> n + pv.nodes) 0 pvs
                        !best   = case pvs of 
                            (pv:pvs) → if pos.turn == WHITE
                                    then (goMaximum pv pvs) 
                                    else (goMinimum pv pvs)
                            unmöglich → error "miniMax has no moves"
                            
    where
        !pos   = applyMove (head hist) m
        !check = inCheck pos pos.turn
        hist'  = pos:hist


strategyAlphaBeta :: Strategy
strategyAlphaBeta gs  = do
        let allMoves = moves gs.current
        if length allMoves == 1
            then do 
                cont ← gs.talkPV PV{moves=[head allMoves], val=0, nodes=1}
                if cont then gs.tellNoMore else pure()
            else tryMoves 3 whiteIsMate blackIsMate  gs [] allMoves 
    where
        tryMoves ∷ Int → Int → Int → GameState  → [Variation] → [Move] → IO ()
        tryMoves depth alpha beta gs pvs [] = if theEndIsNear depth pvs 
                    then gs.tellNoMore
                    else do
                        gs.tellForget
                        if length goodOnes == 1     -- extraordinary move, like mate
                        then do
                            cont ← gs.talkPVs goodOnes
                            if cont then gs.tellNoMore else pure ()
                        else tryMoves (depth+1) whiteIsMate blackIsMate gs [] (varmoves goodOnes)
            where
                !sorted   = if gs.player == WHITE
                    then sortBy (descending Variation.val) pvs
                    else sortBy (ascending Variation.val) pvs
                !goodOnes = pruned gs.player sorted
                varmoves ∷ [Variation] → [Move]
                varmoves pvs = map (head • Variation.moves) pvs
                relevantWhite r x  = x.val >= r
                relevantBlack r x  = x.val <= r
                pruned ∷ Player → [Variation] → [Variation]
                pruned c pvs
                    | length pvs > 10 = if c == WHITE 
                        then (takeWhile (relevantWhite relevance) pvs)
                        else (takeWhile (relevantBlack relevance) pvs)
                    | otherwise = pvs
                    where
                        !max = maximum  pvs
                        !min = minimum  pvs
                        -- das schlechteste 1/3 soll raus
                        -- weiß: 100 -100 -->  200/3 - 100 = 66 - 100 = -43   (43..100)
                        -- schwarz: 100 -100      
                        !relevance = if c == WHITE 
                                    then (max.val - min.val) `quot` 3 + min.val
                                    else max.val - (max.val - min.val) `quot` 3
                
        tryMoves depth alpha beta gs pvs ms
            --| length ms == 1 = do
            --    cout.put (NoMore gs.sid)
            --    pure ()
            | gs.cores == 1 = do
                let m = head ms
                    pv = correctMateDistance (alphaBeta false gs.history depth alpha beta m)
                    -- alpha' = if gs.player == WHITE then 150 `percent` max alpha pv.val else alpha
                    -- beta'  = if gs.player == BLACK then 150 `percent` min beta  pv.val else beta
                    
                println ("tryAlphaBeta " ++ show depth ++ " " ++  algebraic m)
                stdout.println    
                continue ← gs.talkPV pv
                if continue
                then tryMoves depth alpha beta gs (pv:pvs) (tail ms)
                else pure ()
            | otherwise = do
                let !chunk = take gs.cores ms
                    !ms'   = drop gs.cores ms
                    !vs    = mapP (correctMateDistance . alphaBeta false gs.history depth alpha beta) chunk
                println ("tryAlphaBeta " ++ show depth ++ " " ++  display (map algebraic chunk))
                stdout.flush
                let !nodes = fold (+) 0 (map _.nodes vs)    
                when (abs nodes >= 0) stdout.flush 
                continue ← gs.talkPVs vs
                if continue
                then tryMoves depth alpha beta gs (vs++pvs) ms'
                else pure ()


maximize ∷ GameState → Int → Int → Int → [Move] → [Variation]
maximize !gs !d !alpha !beta  []     = []
maximize !gs !d !alpha !beta  (m:ms) = case alphaBeta false gs.history d alpha beta m of
        pv -> pv : maximize gs d alpha' beta' ms where
            alpha' = if gs.player == WHITE then max alpha pv.val else alpha
            beta'  = if gs.player == BLACK then min beta  pv.val else beta

correctMateDistance :: Variation → Variation
correctMateDistance pv =   if pv.val == whiteIsMate then pv.{val = pv.val + dist}
                      else if pv.val == blackIsMate then pv.{val = pv.val - dist}
                      else pv
      where
        dist = length pv.moves

alphaBeta  ∷ Bool → [Position] → Int → Int → Int → Move → Variation
alphaBeta !extended !hist !d !alpha !beta !m
    | stopThinking              =  PV [m] 0 1 
    | null ms                   =  let  val = if check 
                                            then if pos.turn == WHITE then whiteIsMate else blackIsMate
                                            else 0 
                                    in PV [m] val 1
    | pos.getPlyCounter >= 100  = PV [m] 0 1
    | pos `element` hist        = PV [m] 0 1
    | d == 0                    = if targt.piece != EMPTY && not extended  
                                    then alphaBeta true hist 1 alpha beta m 
                                    else PV [m] (eval pos) 1
    | otherwise                 = case alphaBeta extended  hist' (d-1) alpha beta (head ms) of
                                    first → case go extended d pos.turn alpha beta hist' first (tail ms) of
                                        best → PV (m:best.moves) best.val (best.nodes+1)
                                        
    where
        !prev  = head hist
        !targt = whatIsOn prev m.to
        !pos   = applyMove prev m
        !check = inCheck pos pos.turn
        !ms    = moves pos
        hist'  = pos:hist
        
        go ∷ Bool → Int → Player → Int → Int → [Position] → Variation → [Move] → Variation
        go !ext !depth !player !alpha !beta !hist !best [] = best
        go !ext !depth !player !alpha !beta !hist !best (!m:ms)
            -- better pos.turn best beta = best
            | player == WHITE = 
                if best.val >= beta then best
                else case alphaBeta ext hist (depth-1) best.val beta m of
                    next → go ext depth player best.val beta  hist (max best next).{nodes = best.nodes + next.nodes} ms
                
            | otherwise =
                if best.val <= alpha then best
                else case alphaBeta ext hist (depth-1) alpha best.val m of 
                    next → go ext depth  player alpha best.val  hist  (min best next).{nodes = best.nodes + next.nodes} ms


negaMax :: GameState → Bool → Int → Int → Int → Variation
negaMax !gs !extended !depth !alpha !beta
    | stopThinking              =  PV [] 0 1 
    | pos.getPlyCounter >= 100  =  PV [] 0 1
    | pos `element` tail gs.history  = PV [] 0 1
    {- | d == 0                    = if targt.piece != EMPTY && not extended  
                                    then alphaBeta true hist 1 alpha beta m 
                                    else PV [m] (eval pos) 1 -}
    | depth == 0                = PV [] (pos.turn.factor * evalMS pos (moves pos)) 1 
    | otherwise                 = case fromMaybe (oms gs pos depth) (lookup pos gs.openingMap) of
        !m:moves = case applyMove pos m of
                !next → case negaMax gs.{history=next!:gs.history} capture d (-beta) (-alpha) of
                    !pv
                        | pos.getRootDistance == 1,
                          traceLn diag = pv
                        | otherwise = if score >= beta 
                            then cpv
                            else case go gs extended depth (max alpha score) beta cpv moves of
                                best → best.{nodes = best.nodes+0}  -- avoid indirect tail recursion here
                        where
                            !score = negate pv.val 
                            !cpv = PV (m:pv.moves) score pv.nodes  -- candidate pv
                            diag = "# go0 alpha=" ++ show alpha ++ ", beta=" ++ show beta
                                    ++ ", score=" ++ show score 
                                    ++ ", candidate=" ++ joined " "  (map algebraic cpv.moves)
                    where
                            capture = not extended &&  depth == 1 && not (pos.empty m.to) 
                            d = if capture then depth+1 else depth-1 
 
        []
            | check                         = PV [] whiteIsMate 1
            | otherwise                     = PV [] 0 1
                 
                                        
    where
        !pos   = gs.current
        -- ms    = moves pos
        check = inCheck pos pos.turn
        
        oms ∷ GameState → Position → Int → [Move]
        oms gs pos depth = if depth > 1 then orderedMoves pos gs.killerMoves (moves pos) else moves pos
        
        go ∷ GameState → Bool → Int → Int → Int → Variation → [Move] → Variation
        go !gs !ext !depth !alpha !beta !best [] = best
        go !gs !ext !depth !alpha !beta !best (m:ms) 
            -- | otherwise 
            = case applyMove gs.current m of
                !pos →  case negaMax gs.{history=pos!:gs.history} ext (depth-1) (-beta) (-alpha) of
                    !pv → case negate pv.val of
                        !score
                            | gs.current.getRootDistance == 1,
                              traceLn diag = best
                            | otherwise = if score >= beta then killerpv
                                else if (score > alpha)
                                    then go gs ext depth score beta cpv ms
                                    else go gs ext depth alpha beta best.{nodes=best.nodes+pv.nodes} ms
                            where
                                killerpv = pv.{nodes=best.nodes+pv.nodes,moves=m.makeKiller!:pv.moves,val=score}
                                cpv = pv.{nodes=best.nodes+pv.nodes,moves=m!:pv.moves,val=score}
                                diag = "# goN alpha=" ++ show alpha ++ ", beta=" ++ show beta
                                    ++ ", score=" ++ show score ++ (if score > alpha then "!" else " ")
                                    ++ (if score >= beta then "!!" else "") 
                                    ++ " candidate=" ++ joined " "  (map algebraic cpv.moves) 

expectedMoves :: GameState → Maybe [Move]
expectedMoves gs 
    | odd pos.getRootDistance = lookup pos gs.openingMap
    | otherwise = Nothing 
    where 
        pos = gs.current

moveRating ∷ Position → HashMap Move Bool → Move → Int
moveRating pos hash mv = killer + goodCapturing + checking + attacking + badCapturing + castling + pawnMove
    where
        rpos = applyMove pos mv
        -- rmoves = moves rpos
        source = whatIsOn pos mv.from
        target = whatIsOn pos mv.to
        after  = whatIsOn rpos mv.to
        vt = pieceValue target.piece
        killer        = maybe 0 (const 1000) (hash.lookup mv)
        goodCapturing = if  pieceValue mv.piece - vt > 10           then 10 else 0
        castling      = if  mv.piece == KING && mv.promote != EMPTY then 3  else 0
        checking      = if  inCheck rpos rpos.turn                  then 1  else 0
        attacking     = card (pieceTargets source `inter` pos.playerFigures mv.player.opponent)
                            - card (pieceTargets after `inter` rpos.playerFigures mv.player.opponent)  
        badCapturing  = if pieceValue mv.piece - vt < (-10)         then 1  else 0 
        pawnMove      = if endgame rpos && mv.piece == PAWN 
                            then if mv.promote > EMPTY then 10 else 5 
                            else 0

orderedMoves ∷ Position → HashMap Move Bool → [Move] → [Move]
orderedMoves !pos !hash !ms = map fst (sortBy (comparing snd) (zip ms (map (moveRating pos hash) ms))) 

strategyNegaMax ∷ Strategy
strategyNegaMax gs  = do
        let allMoves = moves gs.current
        if length allMoves == 1
            then do 
                cont ← gs.talkPV PV{moves=[head allMoves], val=0, nodes=1}
                if cont then gs.tellNoMore else pure()
            else  tryMoves gs 3 whiteIsMate blackIsMate  [] allMoves
                -- loop gs 3 
    where
        {-
        loop :: GameState -> Int -> IO ()
        loop gs d = do
            let !pvr = negaMax gs false d whiteIsMate blackIsMate
                !pv  = correctMateDistance pvr 
            gs.tellForget
            continue ← gs.talkPV pv
            if continue
                then if length pv.moves + 1 < d 
                        || gs.player == BLACK && pvr.val == whiteIsMate 
                        || gs.player == WHITE && pvr.val == blackIsMate
                    then gs.tellNoMore
                    else loop gs (d+1)
                else pure ()
        -}     
        tryMoves ∷ GameState → Int → Int → Int →  [Variation] → [Move] → IO ()
        tryMoves gs depth alpha beta pvs [] = if theEndIsNear depth pvs 
                    then gs.tellNoMore
                    else do
                        gs.tellForget
                        tryMoves gs (depth+1) whiteIsMate blackIsMate [] (varmoves goodOnes)
            where
                !sorted   = if gs.player == WHITE
                    then sortBy (descending Variation.val) pvs
                    else sortBy (ascending Variation.val) pvs
                !goodOnes = {- pruned gs.player -} sorted
                varmoves ∷ [Variation] → [Move]
                varmoves pvs = map (head • Variation.moves) pvs
                relevantWhite ∷ Int → Variation → Bool
                relevantWhite r x  = x.val >= r
                relevantBlack ∷ Int → Variation → Bool
                relevantBlack r x  = x.val <= r
                pruned ∷ Player → [Variation] → [Variation]
                pruned c pvs
                    | length pvs > 10 = if c == WHITE 
                        then (takeWhile (relevantWhite relevance) pvs)
                        else (takeWhile (relevantBlack relevance) pvs)
                    | otherwise = pvs
                    where
                        !max = maximum  pvs
                        !min = minimum  pvs
                        -- das schlechteste 1/3 soll raus
                        -- weiß: 100 -100 -->  200/3 - 100 = 66 - 100 = -43   (43..100)
                        -- schwarz: 100 -100      
                        !relevance = if c == WHITE 
                                    then (max.val - min.val) `quot` 3 + min.val
                                    else max.val - (max.val - min.val) `quot` 3
                
        tryMoves gs depth alpha beta pvs ms
            --| length ms == 1 = do
            --    cout.put (NoMore gs.sid)
            --    pure ()
            | true || gs.cores == 1 = do
                let m = head ms
                    pos = applyMove gs.current m
                    pv' = correctMateDistance (negaMax gs.{history=pos:gs.history} false (depth-1) (-beta) (-alpha))
                    pv = pv'.{moves=m:pv'.moves, val ← (* pos.turn.factor)}
                    score = negate pv'.val
                    alpha' =  max alpha score
                    newKillers = [ m.clearKiller | m ← pv.moves, m.killer ]
                    killerHash = fold (\h\m → h.insert m true) gs.killerMoves newKillers
                    
                    
                println ("# tryNegaMax " ++ show depth ++ " alpha=" ++  show alpha
                     ++ " beta=" ++  show beta
                     ++ " move=" ++ algebraic m ++ " score=" ++ show score)
                stdout.flush    
                continue ← gs.talkPV pv
                if continue
                then tryMoves gs.{killerMoves=killerHash} depth alpha' beta (pv:pvs) (tail ms)
                else pure ()
                {-
            | otherwise = do
                let !chunk = take gs.cores ms
                    !ms'   = drop gs.cores ms
                    !vs    = mapP (correctMateDistance . alphaBeta false gs.history depth alpha beta) chunk
                println ("tryAlphaBeta " ++ show depth ++ " " ++  display (map algebraic chunk))
                stdout.flush
                let !nodes = fold (+) 0 (map _.nodes vs)    
                when (abs nodes >= 0) stdout.flush 
                continue ← gs.talkPVs vs
                if continue
                then tryMoves depth alpha beta gs (vs++pvs) ms'
                else pure ()
                -}