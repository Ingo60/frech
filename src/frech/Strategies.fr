--- various Strategies, and a main function that selects one
module frech.Strategies where

import frege.control.Concurrent(forkOS, MVar)
import Data.List(sortBy, maximumBy, minimumBy)
import Lib.ForkJoin

import frech.Protocol
import frech.Eval
import frech.Daten

-- type Strategy = GameState -> MVar Command -> MVar Input -> IO ()


initialGS = do
    rvar ← MVar.newEmpty
    tvar ← MVar.newEmpty
    ivar ← MVar.newEmpty
    pure GS{history=[initialBoard], state=FORCED, player=BLACK, cores=2, name="unknown", 
            rvar, tvar, ivar, sid=0, pings=[], best=[], backup=[], myTime=60000, oTime = 60000} 

main [] = main ["best"]            
main [arg] = do
    gs ← initialGS
    forkOS (reader gs.rvar gs.ivar)
    let strategy = case arg of
            "best"      → strategyBest
            "first"     → strategyFirst
            "resign"    → strategyResign
            "minimax"   → strategyMiniMax
            "ab"        → strategyAlphaBeta
            _           → strategyAlphaBeta   
    protocol strategy gs.{name=arg}
    Concurrent.shutdown
main (arg:args) = main [arg] 
     
--- a template for new strategies
strategyTemplate ∷ Strategy
strategyTemplate gs cin cout = do
    if true  -- there is a next move
    then do
        m <- pure M{player=WHITE, piece=PAWN, promote=EMPTY, from=E2, to=E4}
        -- this could have taken a while, let's see if we got something meanwhile
        abort ← cin.poll
        case abort of
            Just false → pure ()   -- abort
            Just true  → println "# protocol error, got CONTINUE before sending move" >> stdout.flush
            Nothing    → do 
                cout.put (MV gs.sid  [PV{moves=[m], val=0, nodes=1}])
                continue <- cin.take
                if continue then strategyTemplate gs cin cout else pure ()
    else do 
        cout.put (NoMore gs.sid)
        pure ()

--- This strategy doesn't know how to play chess, thus it says it doesn't find a move.
--- This causes the driver to resign the game, since it doesn't have a best move so far.
strategyResign :: Strategy
strategyResign gs cin cout = cout.put (NoMore gs.sid)

--- This strategy selects the first move in the list of moves.
--- Scored 3 times draw by repetition in a 10 games match with fairymax!
strategyFirst :: Strategy
strategyFirst gs cin cout = do
    let m = head (moves gs.current)
    cout.put (MV gs.sid [PV{moves=[m], val=0, nodes=1}])
    continue ← cin.take
    if continue then cout.put (NoMore gs.sid) else pure ()

--- This strategy selects the best move (indicated by eval), but doesn't consider opponents replies
strategyBest :: Strategy
strategyBest gs cin cout = do
    let ms = moves gs.current
        best = if gs.current.turn == WHITE 
            then head (sortBy (descending (evalHist gs.history . applyMove gs.current)) ms)
            else head (sortBy (ascending  (evalHist gs.history . applyMove gs.current)) ms)
    cout.put (MV gs.sid [PV{moves=[best], val=0, nodes=1}])
    continue ← cin.take
    if continue then cout.put (NoMore gs.sid) else pure ()


strategyMiniMax :: Strategy
strategyMiniMax gs cin cout = do
        let allMoves = moves gs.current
        if length allMoves == 1
            then do 
                cout.put (MV gs.sid [PV{moves=[head allMoves], val=0, nodes=1}])
                cont ← cin.take
                if cont then cout.put (NoMore gs.sid) else pure()
            else tryMoves 2 cin cout gs [] allMoves 
    where
        tryMoves ∷ Int → MVar Command → MVar Input → GameState  → [Variation] → [Move] → IO ()
        tryMoves depth cin cout gs pvs [] = tryMoves (depth+1) cin cout gs [] (ordered pvs)
            where ordered pvs = map (head • Variation.moves) sorted
                  sorted = if gs.player == WHITE 
                            then sortBy (descending Variation.val) pvs
                            else sortBy (ascending  Variation.val) pvs
        tryMoves depth cin cout gs pvs (m:ms) = do
            let !pvraw = miniMax gs.history depth m
                !pvms  = length pvraw.moves * 100 - 1
                !pv = if pvraw.val == whiteIsMate then pvraw.{val ← (+pvms)}
                      else if pvraw.val == blackIsMate then pvraw.{val ← subtract pvms}
                      else pvraw
            abort ← pure Nothing -- if better then cin.poll else cin.poll       -- make sure it's evaluated
            case abort of
                Just false → println "# strategy aborted" >> stdout.flush
                Just true  → println "# protocol error, got CONTINUE before sending move" >> stdout.flush
                Nothing    →  
                     do
                        cout.put $! (MV gs.sid [pv])
                        continue ← cin.take
                        if continue
                        then tryMoves depth cin cout gs (pv:pvs) ms
                        else pure ()        




miniMax ∷ [Position] → Int → Move → Variation
-- miniMax hist 0 m = PV [m] (eval hist (applyMove (head hist) m)) 1 
miniMax hist n m
    | stopThinking              =  PV [m] 0 1 
    | null ms                   =  let  val = if check 
                                        then if pos.turn == WHITE then whiteIsMate else blackIsMate
                                        else 0 
                                    in PV [m] val 1
    | pos.getPlyCounter >= 100  = PV [m] 0 1
    | pos `element` hist        = PV [m] 0 1
    | n == 0                    = PV [m] (eval pos) 1
    | otherwise                 = best.{nodes, moves ← (m:)} 
    where
        !pos   = applyMove (head hist) m
        !check = inCheck pos pos.turn
        !ms    = moves pos
        hist'  = pos:hist
        pvs    = if n==2 then mapP (miniMax hist' (n-1)) ms else map (miniMax hist' (n-1)) ms 
        nodes  = fold (\n pv -> n + pv.nodes) 0 pvs
        best   = case pvs of 
            (pv:pvs) → if pos.turn == WHITE
                    then (goMaximum pv pvs) 
                    else (goMinimum pv pvs)
            unmöglich → error "miniMax has no moves"

strategyAlphaBeta :: Strategy
strategyAlphaBeta gs cin cout = do
        let allMoves = moves gs.current
        if length allMoves == 1
            then do 
                cout.put (MV gs.sid  [PV{moves=[head allMoves], val=0, nodes=1}])
                cont ← cin.take
                if cont then cout.put (NoMore gs.sid) else pure()
            else tryMoves 3 whiteIsMate blackIsMate cin cout gs [] allMoves 
    where
        tryMoves ∷ Int → Int → Int → MVar Command → MVar Input → GameState  → [Variation] → [Move] → IO ()
        tryMoves depth alpha beta cin cout gs pvs [] = do
                cout.put (Forget gs.sid)
                if length goodOnes == 1     -- extraordinary move, like mate
                then do
                    cout.put (MV gs.sid goodOnes)
                    cont ← cin.take
                    if cont then cout.put (NoMore gs.sid) else pure ()
                else tryMoves (depth+1) whiteIsMate blackIsMate cin cout gs [] (varmoves goodOnes)
            where
                !sorted   = if gs.player == WHITE
                    then sortBy (descending Variation.val) pvs
                    else sortBy (ascending Variation.val) pvs
                !goodOnes = pruned gs.player sorted
                varmoves ∷ [Variation] → [Move]
                varmoves pvs = map (head • Variation.moves) pvs
                relevantWhite r x  = x.val >= r
                relevantBlack r x  = x.val <= r
                pruned ∷ Player → [Variation] → [Variation]
                pruned c pvs
                    | length pvs > 10 = if c == WHITE 
                        then (takeWhile (relevantWhite relevance) pvs)
                        else (takeWhile (relevantBlack relevance) pvs)
                    | otherwise = pvs
                    where
                        !max = maximum  pvs
                        !min = minimum  pvs
                        -- das schlechteste 1/3 soll raus
                        -- weiß: 100 -100 -->  200/3 - 100 = 66 - 100 = -43   (43..100)
                        -- schwarz: 100 -100      
                        !relevance = if c == WHITE 
                                    then (max.val - min.val) `quot` 3 + min.val
                                    else max.val - (max.val - min.val) `quot` 3
                
        tryMoves depth alpha beta cin cout gs pvs ms
            --| length ms == 1 = do
            --    cout.put (NoMore gs.sid)
            --    pure ()
            | gs.cores == 1 = do
                let m = head ms
                    pv = correctMateDistance (alphaBeta false gs.history depth alpha beta m)
                    alpha' = if gs.player == WHITE then 150 `percent` max alpha pv.val else alpha
                    beta'  = if gs.player == BLACK then 150 `percent` min beta  pv.val else beta
                    
                println ("tryAlphaBeta " ++ show depth ++ " " ++  algebraic m)
                stdout.println    
                cout.put $! (MV gs.sid [pv])
                continue ← cin.take
                if continue
                -- then tryMoves depth alpha' beta' cin cout gs (pv:pvs) (tail ms)
                then tryMoves depth alpha beta cin cout gs (pv:pvs) (tail ms)
                else pure ()
            | otherwise = do
                let !chunk = take gs.cores ms
                    !ms'   = drop gs.cores ms
                    !vs    = mapP (correctMateDistance . alphaBeta false gs.history depth alpha beta) chunk
                println ("tryAlphaBeta " ++ show depth ++ " " ++  display (map algebraic chunk))
                stdout.flush
                let !nodes = fold (+) 0 (map _.nodes vs)    
                when (abs nodes >= 0) stdout.flush 
                cout.put $! (MV gs.sid vs)
                continue ← cin.take
                if continue
                -- then tryMoves depth alpha' beta' cin cout gs (pv:pvs) ms
                then tryMoves depth alpha beta cin cout gs (vs++pvs) ms'
                else pure ()


maximize ∷ GameState → Int → Int → Int → [Move] → [Variation]
maximize !gs !d !alpha !beta  []     = []
maximize !gs !d !alpha !beta  (m:ms) = case alphaBeta false gs.history d alpha beta m of
        pv -> pv : maximize gs d alpha' beta' ms where
            alpha' = if gs.player == WHITE then max alpha pv.val else alpha
            beta'  = if gs.player == BLACK then min beta  pv.val else beta

correctMateDistance :: Variation → Variation
correctMateDistance pv =   if pv.val == whiteIsMate then pv.{val = pv.val + dist}
                      else if pv.val == blackIsMate then pv.{val = pv.val - dist}
                      else pv
      where
        dist = length pv.moves * 100 - 1

alphaBeta  ∷ Bool → [Position] → Int → Int → Int → Move → Variation
alphaBeta extended hist !d !alpha !beta m
    | stopThinking              =  PV [m] 0 1 
    | null ms                   =  let  val = if check 
                                            then if pos.turn == WHITE then whiteIsMate else blackIsMate
                                            else 0 
                                    in PV [m] val 1
    | pos.getPlyCounter >= 100  = PV [m] 0 1
    | pos `element` hist        = PV [m] 0 1
    | d == 0                    = if targt.piece != EMPTY && not extended  
                                    then alphaBeta true hist 1 alpha beta m 
                                    else PV [m] (eval pos) 1
    | otherwise                 = case alphaBeta extended  hist' (d-1) alpha beta (head ms) of
                                    first → case go extended d pos.turn alpha beta hist' first (tail ms) of
                                        best → PV (m:best.moves) best.val (best.nodes+1)
                                        
    where
        !prev  = head hist
        !targt = whatIsOn prev m.to
        !pos   = applyMove prev m
        !check = inCheck pos pos.turn
        !ms    = moves pos
        hist'  = pos:hist
        
        go ∷ Bool → Int → Player → Int → Int → [Position] → Variation → [Move] → Variation
        go ext depth player alpha beta hist best [] = best
        go ext depth player alpha beta hist best (m:ms)
            -- better pos.turn best beta = best
            | player == WHITE = 
                if best.val >= beta then best
                else case alphaBeta ext hist (depth-1) best.val beta m of
                    next → go ext depth player best.val beta  hist (max best next).{nodes = best.nodes + next.nodes} ms
                
            | otherwise =
                if best.val <= alpha then best
                else case alphaBeta ext hist (depth-1) alpha best.val m of 
                    next → go ext depth  player alpha best.val  hist  (min best next).{nodes = best.nodes + next.nodes} ms
