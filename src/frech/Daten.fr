--- Basic data structures for the Chess engine
module frech.Daten
    inline (Position.figures, decodeFigure, member, singleton, whatIsOn, bitIndex, card, 
            Position.turn, boolMask,
            Player.factor, Player.opponent) where

import Data.Bits
import Data.Bits public (BitSet.union union, 
                    -- BitSet.member member, 
                    BitSet.difference diff, 
                    BitSet.intersection inter,
                    -- BitSet.singleton singleton
                    )

infixl 13 union diff
infixl 14 inter

{--
    # Geometry of the board
    
    > Rows  -- 8 --- -- 7 --- -- 6 --- -- 5 --- -- 4 --- -- 3 --- -- 2 --- -- 1 ---
    > Files hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba
    > Bits  ........ ........ ........ ........ ........ ........ ........ ........
    > 2^   63     56       48       40       32       24       16        8        0
    
    This means, a step to the *right* (i.e. a1-b1) corresponds to a *left* shift,
    a step to the *left* (i.e. g7-f7) corresponds to a *right* shift,
    a step to towards the eighth row (i.e. e4-e5) corresponds to 8 *left* shifts,
    and a step towards the first row (i.e. c8-c7) corresponds to 8 *right* shifts.
--}
data Index  = A1 | B1 | C1 | D1 | E1 | F1 | G1 | H1
            | A2 | B2 | C2 | D2 | E2 | F2 | G2 | H2
            | A3 | B3 | C3 | D3 | E3 | F3 | G3 | H3
            | A4 | B4 | C4 | D4 | E4 | F4 | G4 | H4
            | A5 | B5 | C5 | D5 | E5 | F5 | G5 | H5
            | A6 | B6 | C6 | D6 | E6 | F6 | G6 | H6
            | A7 | B7 | C7 | D7 | E7 | F7 | G7 | H7
            | A8 | B8 | C8 | D8 | E8 | F8 | G8 | H8
            where
                pure native unsafeFrom "(short)" :: Int -> Index
                pure native ord  "(int)"   :: Index -> Int
                from n | n Int.>= 0 && n Int.< 64 = unsafeFrom n
                         | otherwise        = error ("Index.from: bad index " 
                                                ++ show n 
                                                ++ " (must be 0..63)")
                read :: String  → Maybe Index
                read s = case s of 
                        '^[a-h][1-8]$' = Just $ toEnum ((row `shiftL` 3) + col)
                        other          = Nothing
                    where
                        row = Char.ord (s.charAt 1) - Char.ord '1'
                        col = Char.ord (s.charAt 0) - Char.ord 'a'
                pure native (==)        "=="                :: Index -> Index -> Bool
                pure native (!=)        "!="                :: Index -> Index -> Bool
                pure native hashCode    "(short)"           :: Index -> Int
                pure native (<)         "<"                 :: Index -> Index -> Bool
                pure native (>)         ">"                 :: Index -> Index -> Bool
                pure native (>=)        ">="                :: Index -> Index -> Bool
                pure native (<=)        "<="                :: Index -> Index -> Bool
                i1 <=> i2 = if i1 < i2 then LT else if i1 > i2 then GT else EQ
                succ = from . (1+) . ord
                pred = from . (1-) . ord
                enumFromThen !i1 !i2 = enumFromThenTo i1 i2 (if i1 < i2 then H8 else A1)
                enumFromThenTo !i1 !i2 !i3 = map from (Int.enumFromThenTo (ord i1) (ord i2) (ord i3))
                --- give the rank of a field, e.g. 4 for E4
                rank index = 1 + (ord index `shiftR` 3)
                --- give the file of a field, e.g. \'e\' for E4
                file index = chr ('a'.ord  + (ord index .&. 7)) 


instance Eq Index
instance Ord Index
instance Enum Index


instance Show Index where
    show n = String.format "%c%d" n.file n.rank :: String

--- A bit set for sets of fields
type Fields = BitSet Index

{--
    A position contains information about all figures on the board,
    as well where castling and en passant is possible and who's turn it is.
     
    This is what can be created from a FEN string. 
-}

data Position = P {
    {--
        Encodes castling, en passant position and who's turn it is.
        In addition, whether the kings actually did castle, the 50-moves-rule ply counter
        and the distance to root ply counter.
        
        - If A1 is in the set, it is 'WHITE's turn, otherwise 'BLACK's.
        - If en passant is possible, one of  A3..H3 or A6..H6 is in the set
        - If castling is possible, the corresponding target fields of the Kings
          are in the set. This would be G1 (white kingside), C1 (white queenside),
          G8 (black kingside) or C8 (black queenside).
        - If castling actually was performed, F1, D1, F8 or G8 are set (the field
          that the 'KING' skipped).
        - The bits 'A4' .. 'H4' contain the unsigned half-move counter. It is reset to 0
          on a 'PAWN' move or a capturing move. For all other moves, it is incremented.
        - The bits 'A5' .. 'H5' contain the unsigned root-move counter. It is incremented with
          every move, but reset to 0 after a usermove was carried out. Hence, in searches,
          one can see how many levels deep in the search we are (distance to root), while the
          "depth" parameter of said search functions gives the distance to the horizon.
        
        Note: the counter bits and the F1, D1, F8 and G8 bits are not reflected in the hash key.      
    -}
    !flags   ::  Fields,
    --- Tells the fields that are occupied by white figures
    !whites  ::  Fields,
    {-- 
        For encoding of figures, we use only 3 sets instead of 6, namely        
        'Position.pawnSet', Position.bishopSet' and 'Position.rookSet', with the following
        convention:
        
        > Set       P      B     R
        > PAWN      x      -     -
        > KNIGHT    x      x     -
        > BISHOP    -      x     -
        > ROOK      -      -     x
        > QUEEN     -      x     x
        > KING      x      -     x
    
    --}
    !pawnSet, !bishopSet, !rookSet :: Fields,
    {--
        The Zobrist hash key.
    -}
    !hash :: Long
  } where
    --- Equality of bitmasks up to ply counter
    (==) :: Position → Position → Bool
    p1 == p2 = p1.flags `diff` counterBits BitSet.== p2.flags `diff` counterBits
            && p1.whites    BitSet.== p2.whites
            && p1.pawnSet   BitSet.== p2.pawnSet
            && p1.bishopSet BitSet.== p2.bishopSet
            && p1.rookSet   BitSet.== p2.rookSet
    --- 0 for now
    hashCode p = p.hash.hashCode
    
    --- Tell the fields occupied by 'PAWN's
    --- 'PAWN's have a bit in 'Position.pawnSet' only.
    pawns p = pawnSet p `diff` bishopSet p `diff` rookSet p
    
    --- Tell the fields occupied by 'KNIGHT's
    --- 'KNIGHT's have a bit in 'Position.pawnSet' and 'Position.bishopSet' but not in 'Position.rookSet'.
    knights p = (pawnSet p `inter` bishopSet p) `diff` rookSet p
    
    --- Tell the fields occupied by 'BISHOP's
    --- 'BISHOPS's have a bit in 'Position.bishopSet' only.
    bishops p = (bishopSet p `diff` pawnSet p) `diff` rookSet p

    --- Tell the fields occupied by 'BISHOP's
    --- 'BISHOPS's have a bit in 'Position.bishopSet' only.
    rooks p = (rookSet p `diff` pawnSet p) `diff` bishopSet p

    --- Tell the fields occupied by 'QUEEN's
    --- 'QUEEN's have a bit both in 'Position.rookSet' and 'Position.bishopSet', but not in 'Position.pawnSet' 
    queens p = (bishopSet p `inter` rookSet p) `diff` pawnSet p
    
    --- Tell the fields occupied by 'KING's
    --- 'KING's have a bit both in 'Position.pawnSet' and 'Position.rookSet', but not in 'Position.bishopSet'.
    kings p = (rookSet p `inter` pawnSet p) `diff` bishopSet p

    
    --- constant bitmask for selection of the castling information
    !castlingBits = BitSet.singleton G1 
                `union` BitSet.singleton C1 
                `union` BitSet.singleton G8
                `union` BitSet.singleton C8

    --- constant bitmask for selection of the castling done information
    !castlingDoneBits = BitSet.singleton F1 
                `union` BitSet.singleton D1 
                `union` BitSet.singleton F8
                `union` BitSet.singleton D8
    
    !whiteHasCastledBits = BitSet.singleton F1 `union` BitSet.singleton D1
    !blackHasCastledBits = BitSet.singleton F8 `union` BitSet.singleton D8
    
    playerCastledBits :: Player -> Fields
    playerCastledBits c = if c Player.== WHITE then whiteHasCastledBits else blackHasCastledBits
        
    !enPassantBits = BitSet.fromList (enPassantBlackPawn ++ enPassantWhitePawn)
        where
            enPassantBlackPawn = [A6 .. H6]
            enPassantWhitePawn = [A3 .. H3]
    
    --- constant bitmask for selection of the ply counter
    --- This is used to implement the 50 moves rule
    --- Note that we have room for 256 plies, but only 100 are needed
    !plyCounterBits = BitSet.fromList [A4 .. H4]
    !plyCounterShift = 24
    
    --- constant bitmask for selection of the distance to root ply counter
    --- This counter is reset to 0 before a search starts and incremented with every move
    !rootCounterBits = BitSet.fromList [A5 .. H5]
    !rootCounterShift = 32
    
    !counterBits = plyCounterBits `union` rootCounterBits
    
    --- constant to add or subtract one from both counters in one go
    --- It goes without saying that we must never decrement beyond zero, nor increment beyond 255.
    !onePly = singleton A4 `union` singleton A5
    --- This is used when only the root counter must be incremented (on 'PAWN' moves and captures)
    !onePlyRoot = singleton A5 
        
    --- get the number of 'Move's applied since tha last pawn move or capture
    --- (Castling, despite technically doing 3 moves, corrects the counter acordngly)
    getPlyCounter p = (flags p `inter` plyCounterBits).set `shiftR` plyCounterShift

    getRootDistance :: Position → Long
    getRootDistance p = (p.flags `inter` rootCounterBits).set `shiftR` rootCounterShift
            
    --- clear the 50-move ply counter
    clearPlyCounter :: Position -> Position
    clearPlyCounter pos = pos.{flags = pos.flags `diff` plyCounterBits} 
    
    --- clear the root ply counter
    clearRootPlyCounter :: Position → Position
    clearRootPlyCounter pos = pos.{flags = pos.flags `diff` rootCounterBits}

    --- Increment the ply counter(s) using either 'Position.onePly' or 'Position.onePlyRoot'
    incrPlyCounters :: Position → Fields → Position 
    incrPlyCounters pos mask = pos.{flags = BitSet (BitSet.set pos.flags + BitSet.set mask)}

    --- Decrement both ply counters
    --- Note: it will never be necessary to decrement only one counter. 
    --- Only used after castling, where we actually do 3 ordinary (but illegal) moves.  
    decrPlyCounters :: Position → Position 
    decrPlyCounters pos = pos.{flags = BitSet (BitSet.set pos.flags - BitSet.set onePly)} 
 
    --- subtract 2 from the plyCounter (conveniece for castlings)
    correctPlyCounterForCastling ∷ Position → Position
    correctPlyCounterForCastling p = decrPlyCounters (decrPlyCounters p) 
    
    --- tell if an index is empty 
    empty p index = not (index `member` figures p)
    
    --- tell if all members of the set are empty
    allEmpty p fields = null (fields `inter` figures p)  

    --- tell who's turn it is
    turn :: Position → Player    
    turn p = -- if A1 `member` Position.flags p then WHITE else BLACK
                from (BitSet.set p.flags .&. 1).int
    
    --- all figures
    figures :: Position → Fields
    figures p = p.pawnSet `union` p.bishopSet `union` p.rookSet
    
    --- white figures
    whiteFigures p = figures p `inter` whites p
    --- black figures
    blackFigures p = figures p `diff`  whites p
    --- figures of a give player
    playerFigures pos player = case player of
        WHITE → whiteFigures pos
        BLACK → blackFigures pos
    --- figures of the player whose turn it is
    activeFigures p = playerFigures p (turn p)
    
    --- what is on some index, if any
    on :: Position → Fields → Piece
    on p ix = 
        if (ix `inter` p.pawnSet) BitSet.== ix
            then if (ix `inter` p.bishopSet) BitSet.== ix
                    then if (ix `inter` p.rookSet) BitSet.== ix then EMPTY else KNIGHT
                    else if (ix `inter` p.rookSet) BitSet.== ix then KING  else PAWN 
            else if (ix `inter` p.bishopSet) BitSet.== ix
                    then if (ix `inter` p.rookSet) BitSet.== ix then QUEEN else BISHOP
                    else if (ix `inter` p.rookSet) BitSet.== ix then ROOK  else EMPTY

    --- Compute the hash field
    --- Done only once, and updated with every move
    zobrist :: Position → Long
    zobrist p = foldIndexes zPiece flagz p.figures
        where 
            cond c  = if c `member` p.flags then flagZobrist c else 0L
            flagz = cond A1 .^. cond G1 .^. cond C1 .^. cond G8 .^. cond C8
                .^. cond A3 .^. cond B3 .^. cond C3 .^. cond D3 .^. cond E3 .^. cond F3 .^. cond G3 .^. cond H3
                .^. cond A6 .^. cond B6 .^. cond C6 .^. cond D6 .^. cond E6 .^. cond F6 .^. cond G6 .^. cond H6
            zPiece ix acc = acc .^. ppfZobrist fi.player fi.piece ix
                where fi = whatIsOn p ix 
    rehash :: Position → Position
    rehash p = p.{hash=p.zobrist}
instance Eq Position
deriving Show Position

data Piece = EMPTY | PAWN | KNIGHT | BISHOP | ROOK | QUEEN | KING where
    pure native (==) "=="     :: Piece -> Piece -> Bool
    pure native (!=) "!="     :: Piece -> Piece -> Bool
    pure native hashCode "(short)" :: Piece -> Int

instance Eq Piece
derive Ord Piece
derive Enum Piece

instance Show Piece where
    show EMPTY  = "-"
    show PAWN   = "P"
    show KNIGHT = "N"
    show BISHOP = "B"
    show ROOK   = "R"
    show QUEEN  = "Q"
    show KING   = "K"
    
--- Answer to the question "What is on field xy?"
--- If it's 'EMPTY', the 'FigInfo.player' is meaningless. 
data FigInfo = FI {!player :: Player, !piece :: Piece, !wo :: Fields }
derive Show FigInfo
{--
    Representation of a move
    
    Normally, field 'Move.promote' is 'EMPTY'.
    If piece is 'KING', promote may be 'QUEEN' or 'KING' to indicate queenside or kingside castling.
    If it's a promoting 'PAWN' move, promote may be 'KNIGHT', 'BISHOP', 'ROOK' or 'QUEEN'.
    If it's an en passant capturing, promote will be 'PAWN'.
--}
data Move = M {!player ∷ Player, !piece, !promote ∷ Piece, !from, !to ∷ Index } where
    (==), (!=) ∷ Move → Move → Bool
    m1 == m2 = m1.player Player.== m2.player 
            && m1.piece   Piece.== m2.piece
            && m1.promote Piece.== m2.promote 
            && m1.from    Index.== m2.from 
            && m1.to      Index.== m2.to
    m1 != m2 = m1.player Player.!= m2.player 
            || m1.piece   Piece.!= m2.piece 
            || m1.from    Index.!= m2.from 
            || m1.promote Piece.!= m2.promote
            || m1.to      Index.!= m2.to
    hashCode m = ((m.player.hashCode * 31 + m.piece.hashCode) * 31 + m.from.hashCode) * 31 + m.to.hashCode
instance Eq Move
deriving Show Move

--- The players taking part in the game
data Player = BLACK | WHITE where
    pure native (==) "=="     :: Player -> Player -> Bool
    pure native (!=) "!="     :: Player -> Player -> Bool
    pure native hashCode "(int)"    :: Player -> Int
    pure native ordNum   "(int)"    :: Player -> Int
    pure native unsafeFrom "(short)":: Int -> Player
    
    opponent :: Player -> Player
    opponent p = unsafeFrom (ordNum p .^. 1)

    --- Gives (-1) for 'BLACK' and 1 for 'WHITE' without conditional branching
    --- It is so that ord BLACK is 0, multiplied by 2 is still 0 and 1 subtracted gives -1
    --- Whereas ord WHITE is 1, multiplied by 2 is 2 and 1 subtracted gives 1
    --- (And 'ord' on enumerations is basically a no-op.)
    factor :: Player -> Int
    factor p = 2 * ordNum p - 1
 
-- instance Eq Player
-- deriving Ord Player
deriving Enum Player
deriving Show Player

--- The shade of fields
data Shade = LIGHT | DARK
instance Show Shade where
    show LIGHT = "░"
    show DARK  = "▒"

        
--- gives the bit number of the lowest bit
pure native lowestBit java.lang.Long.numberOfTrailingZeros :: Fields -> Int

--- give the 'Index' of the lowest bit. The 'Fields' set must not be empty!
bitIndex :: Fields → Index
bitIndex = Index.unsafeFrom . lowestBit

--- make a singleton 'Fields' set
singleton :: Index -> Fields
singleton x = BitSet (1L `shiftL` ord x)

--- is some 'Index' member of a 'Fields' set?
member :: Index -> Fields -> Bool
member i s = ((1L `shiftL` ord i) .&. BitSet.set s) != 0

allFields = BitSet (-1L) :: Fields

--- How many elements in this set?
card ∷ BitSet α → Int
card f = popCount (BitSet.set f)

    
indexShade ∷ Index → Shade
indexShade n = if even row == even col then DARK else LIGHT 
    where
        row = ord n `shiftR` 3
        col = ord n .&. 7


--- show 'Move' in algebraic notation
algebraic :: Move → String
algebraic m = show m.from ++ show m.to ++ p
    where
        p = if m.promote >= KNIGHT && m.piece == PAWN then m.promote.show.toLowerCase else ""

--- read 'Move' from algebraic notation
--- Result is 'Nothing' if either the string isn't correct or there is no corresponding move in the list 
unAlgebraic ∷ [Move] → String → Maybe Move
unAlgebraic ms (m~'([a-h][1-8])([a-h][1-8])([nbrq]?)') = listToMaybe (filter corresponding ms)
    where
        from = m.group 1 >>= Index.read
        to   = m.group 2 >>= Index.read 
        prom = case maybe "" String.toUpperCase (m.group 3) of
                "" -> "-"
                x  -> x
        corresponding ∷ Move → Bool
        corresponding move = Just move.from == from && Just move.to == to &&
            (move.piece != PAWN && prom == "-" || prom == show move.promote) 
unAlgebraic invalid garbage = Nothing
--- List of possible 'Moves' in a given 'Position'. 
--- The moves may still turn out illegal due to check.
rawMoves   ∷ Position → [Move]
rawMoves p = foldFields p (castlingMoves p) p.activeFigures
    where
        foldFields ∷  Position → [Move] → Fields → [Move]
        foldFields !p !a !s 
            | null s = a
            | otherwise = foldFields p (genMove p m a) s'
                where
                    !m  = singleton (bitIndex s)
                    s' = s `diff` m
        

--- List of possibe 'Moves' in a given 'Position'
--- Verfied to not leave the 'KING' of the player who moves in check.
moves p = filter p (rawMoves p) []
    where 
        filter ∷ Position → [Move] → [Move] → [Move]
        filter !p []     !acc = acc
        filter !p (m:ms) !acc = if notInCheck (applyMove p m)
            then filter p ms (m:acc)
            else filter p ms acc 

genMove ∷ Position → Fields → [Move] → [Move]
genMove p m ms = foldIndexes p pc ms validTargets
    where
        !pc      = whatIs p m
        !validTargets = pieceTargets pc `diff` p.activeFigures
        foldIndexes ∷ Position → FigInfo → [Move] → Fields → [Move]
        foldIndexes !p !pc !a !s 
            | null s = a
            | otherwise = foldIndexes p pc (addMove p pc m a) s'
                where
                    !m  = bitIndex s
                    s' = s `diff` singleton m



castlingMoves ∷ Position → [Move] 
castlingMoves p = case p.turn of
        WHITE → if shortWhite 
            then if longWhite then [castlingShortWhite, castlingLongWhite] else [castlingShortWhite] 
            else if longWhite then [castlingLongWhite] else []
        BLACK → if shortBlack
            then if longBlack then [castlingShortBlack, castlingLongBlack] else [castlingShortBlack]
            else if longBlack then [castlingLongBlack] else []
    where
        !shortWhite = 
            G1 `member` p.flags                                  -- short castling permitted 
            && p.empty F1 && p.empty G1                          -- fields between king and rook are empty 
            && not (isAttacked p E1 BLACK)                       -- king not in check
            && not (isAttacked p F1 BLACK || isAttacked p G1 BLACK) -- king does not go through/into check
        !longWhite = 
            C1 `member` p.flags                                  -- long castling permitted 
            && p.empty D1 && p.empty C1 && p.empty B1            -- fields between king and rook are empty 
            && not (isAttacked p E1 BLACK)                       -- king not in check
            && not (isAttacked p D1 BLACK || isAttacked p C1 BLACK) -- king does not go through/into check
        !shortBlack = 
            G8 `member` p.flags                                  -- short castling permitted 
            && p.empty F8 && p.empty G8                          -- fields between king and rook are empty 
            && not (isAttacked p E8 WHITE)                       -- king not in check
            && not (isAttacked p F8 WHITE || isAttacked p G8 WHITE) -- king does not go through/into check
        !longBlack = 
            C8 `member` p.flags                                  -- long castling permitted 
            && p.empty D8 && p.empty C8 && p.empty B8            -- fields between king and rook are empty 
            && not (isAttacked p E8 WHITE)                       -- king not in check
            && not (isAttacked p D8 WHITE || isAttacked p C8 WHITE) -- king does not go through/into check


!castlingShortWhite = M{player=WHITE, piece=KING, promote=KING,  from=E1, to=G1} 
!castlingLongWhite  = M{player=WHITE, piece=KING, promote=QUEEN, from=E1, to=C1}
!castlingShortBlack = M{player=BLACK, piece=KING, promote=KING,  from=E8, to=G8} 
!castlingLongBlack  = M{player=BLACK, piece=KING, promote=QUEEN, from=E8, to=C8}

pieceTargets ∷ FigInfo → Fields
pieceTargets pc = case pc.piece of 
        PAWN   → if pc.player == WHITE then whitePawnTargets index else blackPawnTargets index
        KNIGHT → knightTargets  index
        BISHOP → bishopTargets  index
        ROOK   → rookTargets    index
        QUEEN  → bishopTargets  index `union` rookTargets index
        KING   → kingTargets    index
        EMPTY  → empty
    where
        !index   = bitIndex pc.wo
    
 

addMove ∷ Position → FigInfo → Index → [Move] → [Move]
addMove !p pc !to !ms = case pc.piece of
        PAWN  → let 
                    es = if pc.player == WHITE then canWhitePawn from to else canBlackPawn from to
                    valid = if null es -- it's a capturing PAWN move
                        then    to `member` p.playerFigures pc.player.opponent 
                             || to `member` (p.flags `inter` Position.enPassantBits) 
                        else p.allEmpty es
                    promotion = if pc.player == WHITE then to.rank == 8 else to.rank == 1
                in
                    if valid 
                        then if promotion 
                            then fold (\ms x -> move.{promote = x} !: ms) ms promotions
                            else if null es && p.empty to -- en passant capturing 
                                then move.{promote = PAWN} !: ms
                                else move !: ms
                        else ms
        BISHOP → if p.allEmpty (canBishop from to)  then move !: ms else ms
        ROOK   → if p.allEmpty (canRook from to)    then move !: ms else ms
        QUEEN  → if p.allEmpty (canBishop from to) || p.allEmpty (canRook from to)   
                                                    then move !: ms else ms
        other → move !: ms
        
    where
        !move = M {player = pc.player, piece = pc.piece, promote = EMPTY, from, to}
        !from = bitIndex pc.wo

--- 'Piece's a 'PAWN' can be promoted into
!promotions = [QUEEN, ROOK, KNIGHT, BISHOP]
-- ♔♕♖♗♘♙♚♛♜♝♞♟

attacked, attackedByPawns, attackedByBishops, attackedByRooks,
    attackedByBishopsOrQueens, attackedByRooksOrQueens, 
    attackedByQueens, attackedByKnights, attackedByKings ∷ Position → Index → Player → Fields 


{-- 
    Given a 'Position', an 'Index' and a 'Player' computes the 'Fields' that are occupied  by 'Player'
    and contain a 'Piece' that could move to 'Index' (and capture).
    
    Note that computation for 'QUEEN', 'ROOK' and 'BISHOP' attackers require two loops.
    Therefore, whenever one just needs to know *if* the 'Index' is attacked or not, use 'isAttacked'
--} 
attacked p wo durch = attackedByPawns p wo durch
                    `union` attackedByKnights p wo durch 
                    `union` attackedByKings p wo durch
                    `union` attackedByBishopsOrQueens p wo durch 
                    `union` attackedByRooksOrQueens p wo durch  

--- See 'attacked', but reports attacks by 'PAWN's only. O(1)
attackedByPawns p wo durch = if durch == WHITE 
                                then (p.pawns `inter` attackers) `inter` p.whites
                                else (p.pawns `inter` attackers) `diff`  p.whites 
    where
        !attackers = if durch == BLACK then attackingBlackPawns wo else attackingWhitePawns wo

--- See 'attacked', but reports attacks by 'KNIGHT's only. O(1)
attackedByKnights p wo durch = if durch == WHITE    then attackers `inter` p.whites 
                                                    else attackers `diff`  p.whites
    where attackers = p.knights `inter` knightTargets wo

--- See 'attacked', but reports attacks by 'KING's only. O(1)
attackedByKings   p wo durch = if durch == WHITE    then attackers `inter` p.whites 
                                                    else attackers `diff`  p.whites
    where attackers = p.kings   `inter` kingTargets wo

--- See 'attacked', but reports attacks by 'BISHOP's only. Needs 1 bitset fold.
attackedByBishops p wo durch = validBishopTargets p wo pieces  
    where pieces = if durch == WHITE    then p.bishops `inter` p.whites
                                        else p.bishops `diff`  p.whites

--- See 'attacked', but reports attacks by 'ROOK's only. Needs 1 bitset fold.
attackedByRooks   p wo durch = validRookTargets p wo pieces
    where pieces = if durch == WHITE    then p.rooks `inter` p.whites
                                        else p.rooks `diff`  p.whites

--- See 'attacked', but reports attacks by 'QUEEN's only. Needs 2 bitset folds. 
attackedByQueens  p wo durch = validBishopTargets p wo pieces `union` validRookTargets p wo pieces 
    where pieces = if durch == WHITE    then p.queens `inter` p.whites
                                        else p.queens `diff`  p.whites

--- Like 'attackedByBishops', but reports also 'QUEEN's that attack through 'BISHOP' moves. Needs 1 bitset fold
attackedByBishopsOrQueens p wo durch = validBishopTargets p wo pieces 
    where pieces = if durch == WHITE    then (p.bishops   `union` p.queens) `inter` p.whites 
                                        else (p.bishops   `union` p.queens) `diff`  p.whites

--- Like 'attackedByRooks', but reports also 'QUEEN's that attack through 'ROOK' moves. Needs 1 bitset fold.
attackedByRooksOrQueens   p wo durch = validRookTargets  p wo pieces
    where pieces = if durch == WHITE    then (p.rooks   `union` p.queens) `inter` p.whites 
                                        else (p.rooks   `union` p.queens) `diff`  p.whites

--- Like 'attacked', but returns just *whether* the 'Index' is attacked by 'Player'.
--- This may save bitset folds when the 'Index' is indeed attacked by 'PAWN's, 'KNIGHT's or a 'KING'.
isAttacked ∷ Position → Index → Player → Bool
isAttacked p wo durch =    not (null (attackedByPawns           p wo durch))
                        || not (null (attackedByKnights         p wo durch)) 
                        || not (null (attackedByKings           p wo durch)) 
                        || not (null (attackedByBishopsOrQueens p wo durch)) 
                        || not (null (attackedByRooksOrQueens   p wo durch)) 

--- > leastAttacker pos inx player
--- The smallest 'Piece' of 'Player' player that attacks 'Index' inx in 'Positiuon' pos
--- Returns 'EMPTY' if the piece is not attacked
leastAttacker p wo durch
    | not (null (attackedByPawns           p wo durch)) = PAWN
    | not (null (attackedByKnights         p wo durch)) = KNIGHT
    | not (null (attackedByBishops         p wo durch)) = BISHOP
    | not (null (attackedByRooks           p wo durch)) = ROOK  
    | not (null (attackedByQueens          p wo durch)) = QUEEN
    | not (null (attackedByKings           p wo durch)) = KING
    | otherwise                                         = EMPTY

--- Negation of 'isAttacked', but factors out the 'not's and is thus a bit more efficient
isNotAttacked ∷ Position → Index → Player → Bool
isNotAttacked p wo durch = null (attackedByPawns           p wo durch)
                        && null (attackedByKnights         p wo durch) 
                        && null (attackedByKings           p wo durch) 
                        && null (attackedByBishopsOrQueens p wo durch) 
                        && null (attackedByRooksOrQueens   p wo durch) 


--- checks if the 'KING' of some 'Player' stands in check
inCheck ∷ Position → Player → Bool
inCheck p player = isAttacked p king player.opponent
    where 
        !kings = if player == WHITE then p.kings `inter` p.whites else p.kings `diff` p.whites
        !king  = bitIndex kings

--- checks if the 'Position' after a move is valid insofar as the 'KING' of the 'Player' who just moved is not in check
notInCheck p = isNotAttacked p king player
    where
        player = p.turn
        king   = bitIndex kings
        kings  = if player == WHITE then p.kings `diff` p.whites else p.kings `inter` p.whites
 
showUTF ∷ FigInfo → String
showUTF fi = case fi.piece of 
    PAWN    → if fi.player == WHITE then "♙" else "♟"
    KNIGHT  → if fi.player == WHITE then "♘" else "♞"
    BISHOP  → if fi.player == WHITE then "♗" else "♝"
    ROOK    → if fi.player == WHITE then "♖" else "♜"
    QUEEN   → if fi.player == WHITE then "♕" else "♛"
    KING    → if fi.player == WHITE then "♔" else "♚"
    EMPTY   → show . indexShade . bitIndex $ fi.wo 

--- what piece is it, based on combination of pawn, bishop and rook bit?
decodeFigure !pawn !bish !rook = 
    if pawn 
        then if bish
            then if rook then EMPTY else KNIGHT
            else if rook then KING  else PAWN
        else if bish
            then if rook then QUEEN else BISHOP
            else if rook then ROOK  else EMPTY


--- tells what is on the field that is indicated by the (singleton) 'Fields' set.
whatIs ∷ Position → Fields → FigInfo
whatIs p f = FI {player, piece, wo}
    where
        wo = (singleton . bitIndex) f
        player = if null (p.whites `inter` f) then BLACK else WHITE
        pawn = not $ null (p.pawnSet `inter` f)
        bish = not $ null (p.bishopSet `inter` f)
        rook = not $ null (p.rookSet `inter` f)
        piece = decodeFigure pawn bish rook

--- tells what is on the field that is indicated by the 'Index'
whatIsOn p = whatIs p . singleton

--- Place a 'Player's 'Piece' on a certain field or many fields at once.
--- If there is something on the target field(s), it will be removed.
--- It is possible to place 'EMPTY', in this case, 'Player' will be ignored.
--- Not for public use, as it leaves a wrong hash
protected place ∷ Player → Piece → Fields → Position → Position
protected place !player !piece !mask !p = P{flags, whites, pawnSet, bishopSet, rookSet, hash}
    where
        hash   = p.hash 
        flags  = Position.flags p
        whites = if player == WHITE && piece != EMPTY 
                    then p.whites `union` mask 
                    else p.whites `diff`  mask
        pawnSet = if piece == PAWN || piece == KING || piece == KNIGHT
                    then p.pawnSet `union` mask
                    else p.pawnSet `diff`  mask
        bishopSet = if piece == BISHOP || piece == QUEEN || piece == KNIGHT
                    then p.bishopSet `union` mask
                    else p.bishopSet `diff`  mask
        rookSet = if piece == ROOK  || piece == QUEEN || piece == KING
                    then p.rookSet `union` mask
                    else p.rookSet `diff`  mask

placeFigure :: FigInfo → Position → Position
placeFigure fi p = place fi.player fi.piece fi.wo p

whiteToMove ∷ Fields

-- several useful bit masks     
               
!whiteToMove = singleton A1
!blackToMove = empty :: Fields
!whiteCastlingRights = BitSet.fromList [C1, G1]
!blackCastlingRights = BitSet.fromList [C8, G8]

--- Move sequences for castlings consist of 3 moves to get the "who is to move" bit right.
--- Castling rights are taken care of by the ordinary move logic.
--- Since this happens maybe once in a game, efficiency is less important.
!whiteShortCastlingMove1 = M{player=WHITE, piece=KING, promote=EMPTY, from=E1, to=F1}
!whiteShortCastlingMove2 = M{player=WHITE, piece=KING, promote=EMPTY, from=F1, to=G1}
!whiteShortCastlingMove3 = M{player=WHITE, piece=ROOK, promote=EMPTY, from=H1, to=F1}
whiteShortCastling p =  applyMove 
                            (applyMove 
                                (applyMove p whiteShortCastlingMove1) 
                                whiteShortCastlingMove2)
                            whiteShortCastlingMove3

!whiteLongCastlingMove1 = M{player=WHITE, piece=KING, promote=EMPTY, from=E1, to=D1}
!whiteLongCastlingMove2 = M{player=WHITE, piece=KING, promote=EMPTY, from=D1, to=C1}
!whiteLongCastlingMove3 = M{player=WHITE, piece=ROOK, promote=EMPTY, from=A1, to=D1}
whiteLongCastling  p =  applyMove 
                            (applyMove 
                                (applyMove p whiteLongCastlingMove1) 
                                whiteLongCastlingMove2)
                            whiteLongCastlingMove3
!blackShortCastlingMove1 = M{player=BLACK, piece=KING, promote=EMPTY, from=E8, to=F8}
!blackShortCastlingMove2 = M{player=BLACK, piece=KING, promote=EMPTY, from=F8, to=G8}
!blackShortCastlingMove3 = M{player=BLACK, piece=ROOK, promote=EMPTY, from=H8, to=F8}
blackShortCastling p =  applyMove 
                            (applyMove 
                                (applyMove p blackShortCastlingMove1) 
                                blackShortCastlingMove2)
                            blackShortCastlingMove3

!blackLongCastlingMove1 = M{player=BLACK, piece=KING, promote=EMPTY, from=E8, to=D8}
!blackLongCastlingMove2 = M{player=BLACK, piece=KING, promote=EMPTY, from=D8, to=C8}
!blackLongCastlingMove3 = M{player=BLACK, piece=ROOK, promote=EMPTY, from=A8, to=D8}
blackLongCastling p = applyMove 
                            (applyMove 
                                (applyMove p blackLongCastlingMove1) 
                                blackLongCastlingMove2)
                            blackLongCastlingMove3



--- apply a 'Move' to a 'Position'
applyMove ∷ Position → Move → Position
applyMove !p !m 
    | m.piece == KING && m.promote != EMPTY = (castling m p).correctPlyCounterForCastling
    | otherwise = ordinary m p
    where
        ordinary ∷ Move → Position → Position
        ordinary m p = P{flags, whites, pawnSet, bishopSet, rookSet, hash} where
            flags = tomove  `union` castlingRights
                            `union` hasCastledInfo
                            `union` enPassantBits 
                            `union` plies 
            !hash = p.hash 
                    .^. flagZobrist A1    -- switch turn
                    .^. (boolMask (C1 `member` (p.flags `inter` lostCastlingRights)) .&. flagZobrist C1)
                    .^. (boolMask (G1 `member` (p.flags `inter` lostCastlingRights)) .&. flagZobrist G1)
                    .^. (boolMask (C8 `member` (p.flags `inter` lostCastlingRights)) .&. flagZobrist C8)
                    .^. (boolMask (G8 `member` (p.flags `inter` lostCastlingRights)) .&. flagZobrist G8)
                    .^. (boolMask (not (null currentEP))     .&. flagZobrist (bitIndex currentEP))
                    .^. (boolMask (not (null enPassantBits)) .&. flagZobrist (bitIndex enPassantBits))
                    .^. fromHash
                    .^. ppfZobrist m.player piece m.to
                    .^. toHash
            !currentEP = p.flags `inter` Position.enPassantBits
            -- alternate player to move
            tomove = if p.turn == WHITE then blackToMove else whiteToMove
            -- if the moving piece is the KING, the castling rights of the moving player are nullified.
            -- if the move is to A8, H8, A1 or H1 or from A8, H8, A1 or H1 with a ROOK  
            --   the corresponding castling right to C8, G8, Ć1 or G1 gets lost
            --   because this implies that the corresponding ROOK has been moved or captured.
            -- Note 1: In 1. a4 a5 2. b4 b5 3. axb5 axb4 4. Ra8 both long castling rights get lost!
            -- Note 2: Theoretically it is possible, that a KING captures an unmoved ROOK thus we must
            -- check both KING moves and moves to or from edges!
            !castlingRights = (p.flags `inter` Position.castlingBits) 
                            `diff` lostCastlingRights
            -- LCR means "lost castling rights"
            !lostCastlingRights = kingMoveLCR `union` rookMoveLCR `union` rookCaptureLCR 
            kingMoveLCR = if m.piece == KING
                                            then if m.player == WHITE
                                                then  whiteCastlingRights
                                                else  blackCastlingRights
                                            else empty 
            rookMoveLCR = if m.from == A8 then singleton C8
                                            else if m.from == H8 then singleton G8
                                            else if m.from == A1 then singleton C1
                                            else if m.from == H1 then singleton G1
                                            else empty
            rookCaptureLCR = if m.to == A8 then singleton C8
                                            else if m.to == H8 then singleton G8
                                            else if m.to == A1 then singleton C1
                                            else if m.to == H1 then singleton G1
                                            else empty
            !hasCastledInfo = if m.piece == KING 
                then if m.player == WHITE
                    then     if m.from == E1 && m.to == G1 then singleton F1
                        else if m.from == E1 && m.to == C1 then singleton D1 else empty
                    else     if m.from == E8 && m.to == G8 then singleton F8
                    else     if m.from == E8 && m.to == C8 then singleton D8 else empty
                else empty
                
            !enPassantBits = if m.piece == PAWN
                then if m.player == WHITE
                    then if ord m.to == ord m.from + 16
                        then singleton (from (ord m.from + 8))
                        else empty
                    else if ord m.to == ord m.from - 16 
                        then singleton (from (ord m.from - 8))
                        else empty
                else empty
            -- increment number of plies, unless it's a capture or PAWN move
            !plies = if m.piece == PAWN || not (p.empty m.to)
                    then BitSet ((p.flags `inter` Position.counterBits).set + Position.onePlyRoot.set) 
                    else BitSet ((p.flags `inter` Position.counterBits).set + Position.onePly.set)
            -- fields that will be empty after the move
            !fromMask = if m.promote == PAWN -- en passant capture
                        then if m.player == WHITE 
                            then singleton m.from `union` singleton (from (ord m.to - 8))
                            else singleton m.from `union` singleton (from (ord m.to + 8))
                        else singleton m.from
            -- this must be xor'ed out from the hash
            !fromHash = ppfZobrist m.player m.piece m.from      -- the piece from the "from" square
                            .^.  if m.promote == PAWN -- en passant capture
                                    then    -- remove opponents PAWN 
                                        ppfZobrist m.player.opponent PAWN 
                                                            (if m.player == WHITE 
                                                                    then from (ord m.to - 8)
                                                                    else from (ord m.to + 8))
                                    else 0
            -- field that will be set after the move
            !toMask = singleton m.to
            !toHash = if p.empty m.to then 0
                        else ppfZobrist  m.player.opponent  (p.on (singleton m.to))  m.to 
            !piece  = if m.piece == PAWN && m.promote >= KNIGHT then m.promote else m.piece 
            !whites = if m.player == WHITE then (p.whites `diff` fromMask) `union` toMask 
                        else  p.whites `diff` (fromMask `union` toMask) 
            !pawnSet = if piece == PAWN || piece == KING || piece == KNIGHT
                        then (p.pawnSet `diff` fromMask) `union` toMask
                        else p.pawnSet `diff` (fromMask  `union` toMask)
            !bishopSet = if piece == BISHOP || piece == QUEEN || piece == KNIGHT
                        then (p.bishopSet `diff` fromMask) `union` toMask
                        else p.bishopSet `diff`  (fromMask  `union` toMask)
            !rookSet = if piece == ROOK  || piece == QUEEN || piece == KING
                        then (p.rookSet `diff` fromMask) `union` toMask
                        else p.rookSet `diff`  (fromMask  `union` toMask)
        castling ∷ Move → Position → Position
        castling m p = if m.player == WHITE
                        then if m.promote == KING 
                            then (whiteShortCastling p).{flags ← union (singleton F1)} 
                            else (whiteLongCastling p) .{flags ← union (singleton D1)}
                        else if m.promote == KING 
                            then (blackShortCastling p).{flags ← union (singleton F8)} 
                            else (blackLongCastling p) .{flags ← union (singleton D8)} 


pure native bcomp "java.lang.Boolean.compare" :: Bool → Bool → Int

--- branchless equivalent to
--- > if null set then 0L else -1L
boolMask = Int.long . bcomp false

--- set the "stop thinking" flag to *true*
native finishThinking frech.MDB.finishThinking ∷ () → IO ()

--- set the "stop thinking" flag to *false*
native beginThinking frech.MDB.beginThinking ∷ () → IO ()

{-- 
    The stop thinking flag.

    Apologies for cheating with IO here. But it doesn't change anything, except that searches
    will end with the next iteration. It did work without this flag very well, except that when 2
    engines play against each other, it may take a few seconds before a timed out search actually
    finishes. And this steals massive amounts of computing ressources from the opponent, while his
    clock is running, which distorts the picture.
-}
pure native stopThinking frech.MDB.stopThinking ∷ Bool 

--- Zobrist hash constants for 'Player', 'Piece' and 'Field'
pure native ppfZobrist frech.MDB.ppfZobrist ∷ Player → Piece → Index → Long

--- Zobrist hash constants for 'Position.flags' indexes
pure native flagZobrist frech.MDB.flagZobrist ∷ Index → Long

--- The set of fields a 'WHITE' 'PAWN' on some 'Index' can go potentially
pure native whitePawnTargets    frech.MDB.whitePawnTargets ∷ Index → Fields
--- The set of fields a 'BLACK' 'PAWN' on some 'Index' can go potentially
pure native blackPawnTargets    frech.MDB.blackPawnTargets ∷ Index → Fields

--- The set of fields a 'KNIGHT' on some 'Index' can go to
pure native knightTargets   frech.MDB.knightTargets   :: Index → Fields

--- The set of fields a 'KING' on some 'Index' can go to
pure native kingTargets     frech.MDB.kingTargets     :: Index → Fields

--- The set of fields a 'ROOK' on some 'Index' can go to if there are no non 'EMPTY' fields. 
pure native rookTargets     frech.MDB.rookTargets     :: Index → Fields

--- The set of fields a 'BISHOP' on some 'Index' can go to if there are no non 'EMPTY' fields.
pure native bishopTargets   frech.MDB.bishopTargets   :: Index → Fields

--- The set of fields that must be 'EMPTY' to make a 'BISHOP' move valid.
--- Returns a set with all fields if the move is never valid, for example
--- > canBishop A1 A2 == BitSet 0xFFFFFFFFFFFFFFFFL
--- > canBishop A1 B2 == empty  -- no EMPTY fields required
--- > canBishop A1 C3 == singleton B2
pure native canBishop       frech.MDB.canBishop       :: Index → Index → Fields

--- The set of fields that must be 'EMPTY' to make a 'ROOK' move valid.
--- Returns a set with all fields if the move is never valid, for example
--- > canRook A1 B2 == BitSet 0xFFFFFFFFFFFFFFFFL
--- > canRook A1 A2 == empty  -- no EMPTY fields required
--- > canRook A1 C1 == singleton B1
pure native canRook         frech.MDB.canRook         :: Index → Index → Fields

--- The set of fields that must be 'EMPTY' to make a 'WHITE' 'PAWN' move valid.
--- Returns a set with all bits set if the move is never valid.
--- Returns 'empty' if this is a capturing move, it needs to check in addition whether the target is occupied by the opponent.
--- Returns the target and the skipped field, if any, for forward moves.
pure native canWhitePawn    frech.MDB.canWhitePawn  ∷ Index → Index → Fields
pure native canBlackPawn    frech.MDB.canBlackPawn  ∷ Index → Index → Fields 

--- The set of fields from where a WHITE/BLACK pawn could attack
pure native attackingWhitePawns frech.MDB.targetOfWhitePawns ∷ Index → Fields
pure native attackingBlackPawns frech.MDB.targetOfBlackPawns ∷ Index → Fields 

drawBoard p = do
    let indexes = [[A8…H8], [A7…H7], [A6…H6], [A5…H5], [A4…H4], [A3…H3], [A2…H2], [A1…H1]]
        fis = map (map (showUTF . whatIsOn p)) indexes
        lines = map (joined "") fis
    mapM_ println lines



foldFields ∷ (Fields→α→α) → α → Fields → α
foldFields !f !a !s 
    | null s = a
    | otherwise = foldFields f (f m a) s'
        where
            !m  = singleton (bitIndex s)
            s' = s `diff` m

foldIndexes ∷ (Index→α→α) → α → Fields → α
foldIndexes !f !a !s 
    | null s = a
    | otherwise = foldIndexes f (f m a) s'
        where
            !m  = bitIndex s
            s' = s `diff` singleton m

filterFields ∷ (Index → Bool) → Fields → Fields
filterFields !f !s = go f s empty
    where
        go ∷ (Index→Bool) → Fields → Fields → Fields
        go !f !s !r
            | null s    = r
            | f to      = go f (s `diff` m) (r `union` m)
            | otherwise = go f (s `diff` m) r 
            where
                !to = bitIndex s 
                !m  = singleton to    

validBishopTargets, validRookTargets ∷ Position → Index → Fields → Fields
--- Computes where a 'BISHOP' on a given 'Index' actually can go in the 'Position', but restricted to certain fields.
validBishopTargets p from mask = go p from (mask `inter` bishopTargets from) empty 
    where
        go ∷ Position → Index → Fields → Fields → Fields
        go !p !from !s !r
            | null s = r
            | p.allEmpty (canBishop from to)    = go p from (s `diff` m) (r `union` m)
            | otherwise                         = go p from (s `diff` m)  r
            where
                !to = bitIndex s 
                !m  = singleton to    

--- Computes where a 'ROOK' on a given 'Index' actually can go in the 'Position', but restricted to certain fields.
validRookTargets p from mask = go p from (mask `inter` rookTargets from) empty 
    where
        go ∷ Position → Index → Fields → Fields → Fields
        go !p !from !s !r
            | null s = r
            | p.allEmpty (canRook from to)  = go p from (s `diff` m) (r `union` m)
            | otherwise                     = go p from (s `diff` m)  r
            where
                !to = bitIndex s 
                !m  = singleton to    


!emptyBoard = (P empty empty empty empty empty 0L)
!initialBoard = Position.rehash
               . Position.{flags = singleton A1 `union` Position.castlingBits} 
               . place WHITE PAWN (BitSet.fromList [A2, B2, C2, D2, E2, F2, G2, H2])
               . place BLACK PAWN (BitSet.fromList [A7, B7, C7, D7, E7, F7, G7, H7])
               . place WHITE KING (singleton E1)
               . place BLACK KING (singleton E8)
               . place WHITE QUEEN (singleton D1)
               . place BLACK QUEEN (singleton D8)
               . place WHITE ROOK (BitSet.fromList [A1, H1])
               . place BLACK ROOK (BitSet.fromList [A8, H8])
               . place WHITE KNIGHT (BitSet.fromList [B1, G1])
               . place BLACK KNIGHT (BitSet.fromList [B8, G8])
               . place WHITE BISHOP (BitSet.fromList [C1, F1])
               . place BLACK BISHOP (BitSet.fromList [C8, F8]) 
               $ emptyBoard

testmain = do
    drawBoard emptyBoard
    print "Knight: "
    println (knightTargets E4)
    print "King: "
    println (kingTargets E4)
    print "Rook: "
    println (rookTargets E4)
    print "Bishop: "
    println (bishopTargets E4)
    let b = foldFields (place BLACK PAWN) emptyBoard (bishopTargets E4)
    drawBoard (place WHITE BISHOP (singleton E4) b)