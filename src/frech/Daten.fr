--- Basic data structures for the Chess engine
module frech.Daten
    inline (Position.figures, decodeFigure, member, singleton, whatIsOn, bitIndex) where

import Data.Bits
import Data.Bits public (BitSet.union union, 
                    -- BitSet.member member, 
                    BitSet.difference diff, 
                    BitSet.intersection inter,
                    -- BitSet.singleton singleton
                    )

infixl 13 union diff
infixl 14 inter

{--
    # Geometry of the board
    
    > Rows  -- 8 --- -- 7 --- -- 6 --- -- 5 --- -- 4 --- -- 3 --- -- 2 --- -- 1 ---
    > Files hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba
    > Bits  ........ ........ ........ ........ ........ ........ ........ ........
    > 2^   63     56       48       40       32       24       16        8        0
    
    This means, a step to the *right* (i.e. a1-b1) corresponds to a *left* shift,
    a step to the *left* (i.e. g7-f7) corresponds to a *right* shift,
    a step to towards the eighth row (i.e. e4-e5) corresponds to 8 *left* shifts,
    and a step towards the first row (i.e. c8-c7) corresponds to 8 *right* shifts.
--}
data Index  = A1 | B1 | C1 | D1 | E1 | F1 | G1 | H1
            | A2 | B2 | C2 | D2 | E2 | F2 | G2 | H2
            | A3 | B3 | C3 | D3 | E3 | F3 | G3 | H3
            | A4 | B4 | C4 | D4 | E4 | F4 | G4 | H4
            | A5 | B5 | C5 | D5 | E5 | F5 | G5 | H5
            | A6 | B6 | C6 | D6 | E6 | F6 | G6 | H6
            | A7 | B7 | C7 | D7 | E7 | F7 | G7 | H7
            | A8 | B8 | C8 | D8 | E8 | F8 | G8 | H8
            where
                pure native unsafeFrom "(short)" :: Int -> Index
                pure native ord  "(int)"   :: Index -> Int
                from n | n Int.>= 0 && n Int.< 64 = unsafeFrom n
                         | otherwise        = error ("Index.from: bad index " 
                                                ++ show n 
                                                ++ " (must be 0..63)")
                read :: String  → Maybe Index
                read s = case s of 
                        '^[a-h][1-8]$' = Just $ toEnum ((row `shiftL` 3) + col)
                        other          = Nothing
                    where
                        row = Char.ord (s.charAt 1) - Char.ord '1'
                        col = Char.ord (s.charAt 0) - Char.ord 'a'
                pure native (==)        "=="                :: Index -> Index -> Bool
                pure native (!=)        "!="                :: Index -> Index -> Bool
                pure native hashCode    "(short)"           :: Index -> Int
                pure native (<)         "<"                 :: Index -> Index -> Bool
                pure native (>)         ">"                 :: Index -> Index -> Bool
                pure native (>=)        ">="                :: Index -> Index -> Bool
                pure native (<=)        "<="                :: Index -> Index -> Bool
                i1 <=> i2 = if i1 < i2 then LT else if i1 > i2 then GT else EQ
                succ = from . (1+) . ord
                pred = from . (1-) . ord
                enumFromThen !i1 !i2 = enumFromThenTo i1 i2 (if i1 < i2 then H8 else A1)
                enumFromThenTo !i1 !i2 !i3 = map from (Int.enumFromThenTo (ord i1) (ord i2) (ord i3))
                --- give the rank of a field, e.g. 4 for E4
                rank index = 1 + (ord index `shiftR` 3)
                --- give the file of a field, e.g. \'e\' for E4
                file index = chr ('a'.ord  + (ord index .&. 7)) 


instance Eq Index
instance Ord Index
instance Enum Index


instance Show Index where
    show n = String.format "%c%d" n.file n.rank :: String
        
--- gives the bit number of the lowest bit
pure native lowestBit java.lang.Long.numberOfTrailingZeros :: Fields -> Int

--- give the 'Index' of the lowest bit. The 'Fields' set must not be empty!
bitIndex :: Fields → Index
bitIndex = Index.unsafeFrom . lowestBit

--- make a singleton 'Fields' set
singleton :: Index -> Fields
singleton x = BitSet (1L `shiftL` ord x)

--- is some 'Index' member of a 'Fields' set?
member :: Index -> Fields -> Bool
member i s = ((1L `shiftL` ord i) .&. BitSet.set s) != 0

--- A bit set for sets of fields
type Fields = BitSet Index

allFields = BitSet (-1L) :: Fields

--- The players taking part in the game
data Player = BLACK | WHITE where
    pure native (==) "=="     :: Player -> Player -> Bool
    pure native (!=) "!="     :: Player -> Player -> Bool
    pure native hashCode "(short)" :: Player -> Int
    
    opponent BLACK = WHITE
    opponent WHITE = BLACK
-- instance Eq Player
-- deriving Ord Player
deriving Enum Player
deriving Show Player

--- The shade of fields
data Shade = LIGHT | DARK
instance Show Shade where
    show LIGHT = "░"
    show DARK  = "▒"
    
indexShade ∷ Index → Shade
indexShade n = if even row == even col then DARK else LIGHT 
    where
        row = ord n `shiftR` 3
        col = ord n .&. 7

{--
    A position contains information about all figures on the board,
    as well where castling and en passant is possible and who's turn it is.
     
    This is what can be created from a FEN string. 
-}

data Position = P {
    {--
        Encodes castling, en passant position and who's turn it is.
        
        - If en passant is possible, one of  A3..H3 or A6..H6 is in the set
        - If castling is possible, the corresponding target fields of the Kings
        are in the set. This would be G1 (white kingside), C1 (white queenside),
        G8 (black kingside) or C8 (black queenside).
        - If A1 is in the set, it is 'WHITE's turn, otherwise 'BLACK's.     
    -}
    !flags   ::  Fields,
    --- Tells the fields that are occupied by white figures
    !whites  ::  Fields,
    {-- 
        For encoding of figures, we use only 3 sets instead of 6, namely        
        'Position.pawnSet', Position.bishopSet' and 'Position.rookSet', with the following
        convention:
        
        > Set       P      B     R
        > PAWN      x      -     -
        > KNIGHT    x      x     -
        > BISHOP    -      x     -
        > ROOK      -      -     x
        > QUEEN     -      x     x
        > KING      x      -     x
    
    --}
    !pawnSet, !bishopSet, !rookSet :: Fields,
  } where
    
    --- Tell the fields occupied by 'PAWN's
    --- 'PAWN's have a bit in 'Position.pawnSet' only.
    pawns p = pawnSet p `diff` bishopSet p `diff` rookSet p
    
    --- Tell the fields occupied by 'KNIGHT's
    --- 'KNIGHT's have a bit in 'Position.pawnSet' and 'Position.bishopSet' but not in 'Position.rookSet'.
    knights p = (pawnSet p `inter` bishopSet p) `diff` rookSet p
    
    --- Tell the fields occupied by 'BISHOP's
    --- 'BISHOPS's have a bit in 'Position.bishopSet' only.
    bishops p = (bishopSet p `diff` pawnSet p) `diff` rookSet p

    --- Tell the fields occupied by 'BISHOP's
    --- 'BISHOPS's have a bit in 'Position.bishopSet' only.
    rooks p = (rookSet p `diff` pawnSet p) `diff` bishopSet p

    --- Tell the fields occupied by 'QUEEN's
    --- 'QUEEN's have a bit both in 'Position.rookSet' and 'Position.bishopSet', but not in 'Position.pawnSet' 
    queens p = (bishopSet p `inter` rookSet p) `diff` pawnSet p
    
    --- Tell the fields occupied by 'KING's
    --- 'KING's have a bit both in 'Position.pawnSet' and 'Position.rookSet', but not in 'Position.bishopSet'.
    kings p = (rookSet p `inter` pawnSet p) `diff` bishopSet p

    
    --- constant bitmask for selection of the castling information
    !castlingBits = BitSet.singleton G1 
                `union` BitSet.singleton C1 
                `union` BitSet.singleton G8
                `union` BitSet.singleton C8
    
    !enPassantBits = BitSet.fromList (enPassantBlackPawn ++ enPassantWhitePawn)
        where
            enPassantBlackPawn = [A6 .. H6]
            enPassantWhitePawn = [A3 .. H3]

    --- tell if an index is empty 
    empty p index = not (index `member` figures p)
    
    --- tell if all members of the set are empty
    allEmpty p fields = null (fields `inter` figures p)  

    --- tell who's turn it is    
    turn p = if A1 `member` Position.flags p then WHITE else BLACK
    
    --- all figures
    figures :: Position → Fields
    figures p = p.pawnSet `union` p.bishopSet `union` p.rookSet
    
    --- white figures
    whiteFigures p = figures p `inter` whites p
    --- black figures
    blackFigures p = figures p `diff`  whites p
    --- figures of a give player
    playerFigures pos player = case player of
        WHITE → whiteFigures pos
        BLACK → blackFigures pos
    --- figures of the player whose turn it is
    activeFigures p = playerFigures p (turn p)

    
deriving Show Position

data Piece = EMPTY | PAWN | KNIGHT | BISHOP | ROOK | QUEEN | KING where
    pure native (==) "=="     :: Piece -> Piece -> Bool
    pure native (!=) "!="     :: Piece -> Piece -> Bool
    pure native hashCode "(short)" :: Piece -> Int

instance Eq Piece
derive Ord Piece
derive Enum Piece

instance Show Piece where
    show EMPTY  = "?"
    show PAWN   = "P"
    show KNIGHT = "N"
    show BISHOP = "B"
    show ROOK   = "R"
    show QUEEN  = "Q"
    show KING   = "K"
    
--- Answer to the question "What is on field xy?"
--- If it's 'EMPTY', the 'FigInfo.player' is meaningless. 
data FigInfo = FI {!player :: Player, !piece :: Piece, !wo :: Fields }


--- representation of a move
data Move = M {!player ∷ Player, !piece, !promote ∷ Piece, !from, !to ∷ Index } where
    (==), (!=) ∷ Move → Move → Bool
    m1 == m2 = m1.player Player.== m2.player 
            && m1.piece   Piece.== m2.piece
            && m1.promote Piece.== m2.promote 
            && m1.from    Index.== m2.from 
            && m1.to      Index.== m2.to
    m1 != m2 = m1.player Player.!= m2.player 
            || m1.piece   Piece.!= m2.piece 
            || m1.from    Index.!= m2.from 
            || m1.promote Piece.!= m2.promote
            || m1.to      Index.!= m2.to
    hashCode m = ((m.player.hashCode * 31 + m.piece.hashCode) * 31 + m.from.hashCode) * 31 + m.to.hashCode
instance Eq Move
deriving Show Move

moves ∷ Position → [Move]
moves p = foldFields (genMove p) [] p.activeFigures

genMove p m ms = foldIndexes (addMove p pc) ms validTargets
    where
        !pc      = whatIs p m
        !index   = bitIndex pc.wo
        !targets = case pc.piece of 
            PAWN   → if pc.player == WHITE then whitePawnTargets index else blackPawnTargets index
            KNIGHT → knightTargets  index
            BISHOP → bishopTargets  index
            ROOK   → rookTargets    index
            QUEEN  → bishopTargets  index `union` rookTargets index
            KING   → kingTargets    index
            EMPTY  → empty
        !validTargets = targets `diff` p.activeFigures


addMove ∷ Position → FigInfo → Index → [Move] → [Move]
addMove p pc to ms = case pc.piece of
        PAWN  → let 
                    !es = if pc.player == WHITE then canWhitePawn from to else canBlackPawn from to
                    !valid = if null es 
                        then    to `member` p.playerFigures pc.player.opponent 
                             || to `member` (p.flags `inter` Position.enPassantBits) 
                        else p.allEmpty es
                    !promotion = if pc.player == WHITE then to.rank == 8 else to.rank == 1
                in
                    if valid 
                        then if promotion 
                            then fold (\ms x -> move x !: ms) ms [QUEEN, ROOK, KNIGHT, BISHOP]
                            else move EMPTY !: ms
                        else ms
        BISHOP → if p.allEmpty (canBishop from to)  then move EMPTY !: ms else ms
        ROOK   → if p.allEmpty (canRook from to)    then move EMPTY !: ms else ms
        QUEEN  → if p.allEmpty (canBishop from to) || p.allEmpty (canRook from to)   
                                                    then move EMPTY !: ms else ms
        other → move EMPTY !: ms
        
    where
        move !x = M {player = pc.player, piece = pc.piece, promote = x, from, to}
        !from = bitIndex pc.wo   
-- ♔♕♖♗♘♙♚♛♜♝♞♟

attacked, attackedByPawns, attackedByBishops, attackedByRooks,
    attackedByBishopsOrQueens, attackedByRooksOrQueens, 
    attackedByQueens, attackedByKnights, attackedByKings ∷ Position → Index → Player → Fields 


{-- 
    Given a 'Position', an 'Index' and a 'Player' computes the 'Fields' that are occupied  by 'Player'
    and contain a 'Piece' that could move to 'Index' (and capture).
    
    Note that computation for 'QUEEN', 'ROOK' and 'BISHOP' attackers require two loops.
    Therefore, whenever one just needs to know *if* the 'Index' is attacked or not, use 'isAttacked'
--} 
attacked p wo durch = if durch == WHITE then attackers `inter` p.whites else attackers `diff` p.whites
    where
        attackers = attackedByPawns p wo durch
                    `union` attackedByKnights p wo durch `union` attackedByKings p wo durch
                    `union` attackedByBishopsOrQueens p wo durch `union` attackedByRooksOrQueens p wo durch  

--- See 'attacked', but reports attacks by 'PAWN's only. O(1)
attackedByPawns p wo durch = p.pawns `inter` attackers where
    !attackers = if durch == BLACK then attackingBlackPawns wo else attackingWhitePawns wo

--- See 'attacked', but reports attacks by 'KNIGHT's only. O(1)
attackedByKnights p wo durch = if durch == WHITE    then attackers `inter` p.whites 
                                                    else attackers `diff`  p.whites
    where attackers = p.knights `inter` knightTargets wo

--- See 'attacked', but reports attacks by 'KING's only. O(1)
attackedByKings   p wo durch = if durch == WHITE    then attackers `inter` p.whites 
                                                    else attackers `diff`  p.whites
    where attackers = p.kings   `inter` kingTargets wo

--- See 'attacked', but reports attacks by 'BISHOP's only. Needs 1 bitset fold.
attackedByBishops p wo durch = validBishopTargets p wo pieces  
    where pieces = if durch == WHITE    then p.bishops `inter` p.whites
                                        else p.bishops `diff`  p.whites

--- See 'attacked', but reports attacks by 'ROOK's only. Needs 1 bitset fold.
attackedByRooks   p wo durch = validRookTargets p wo pieces
    where pieces = if durch == WHITE    then p.rooks `inter` p.whites
                                        else p.rooks `diff`  p.whites

--- See 'attacked', but reports attacks by 'QUEEN's only. Needs 2 bitset folds. 
attackedByQueens  p wo durch = validBishopTargets p wo pieces `union` validRookTargets p wo pieces 
    where pieces = if durch == WHITE    then p.queens `inter` p.whites
                                        else p.queens `diff`  p.whites

--- Like 'attackedByBishops', but reports also 'QUEEN's that attack through 'BISHOP' moves. Needs 1 bitset fold
attackedByBishopsOrQueens p wo durch = validBishopTargets p wo pieces 
    where pieces = if durch == WHITE    then (p.bishops   `union` p.queens) `inter` p.whites 
                                        else (p.bishops   `union` p.queens) `diff`  p.whites

--- Like 'attackedByRooks', but reports also 'QUEEN's that attack through 'ROOK' moves. Needs 1 bitset fold.
attackedByRooksOrQueens   p wo durch = validRookTargets  p wo pieces
    where pieces = if durch == WHITE    then (p.rooks   `union` p.queens) `inter` p.whites 
                                        else (p.rooks   `union` p.queens) `diff`  p.whites

--- Like 'attacked', but returns just *whether* the 'Index' is attacked by 'Player'.
--- This may save bitset folds when the 'Index' is indeed attacked by 'PAWN's, 'KNIGHT's or a 'KING'.
isAttacked ∷ Position → Index → Player → Bool
isAttacked p wo durch =    not (null (attackedByPawns           p wo durch))
                        || not (null (attackedByKnights         p wo durch)) 
                        || not (null (attackedByKings           p wo durch)) 
                        || not (null (attackedByBishopsOrQueens p wo durch)) 
                        || not (null (attackedByRooksOrQueens   p wo durch)) 

--- checks if the 'KING' of some 'Player' stands in check
inCheck ∷ Position → Player → Bool
inCheck p player = isAttacked p king player.opponent
    where 
        !kings = if player == WHITE then p.kings `inter` p.whites else p.kings `diff` p.whites
        !king  = bitIndex kings

showUTF ∷ FigInfo → String
showUTF fi = case fi.piece of 
    PAWN    → if fi.player == WHITE then "♙" else "♟"
    KNIGHT  → if fi.player == WHITE then "♘" else "♞"
    BISHOP  → if fi.player == WHITE then "♗" else "♝"
    ROOK    → if fi.player == WHITE then "♖" else "♜"
    QUEEN   → if fi.player == WHITE then "♕" else "♛"
    KING    → if fi.player == WHITE then "♔" else "♚"
    EMPTY   → show . indexShade . bitIndex $ fi.wo 

--- what piece is it, based on combination of pawn, bishop and rook bit?
decodeFigure !pawn !bish !rook = 
    if pawn 
        then if bish
            then if rook then EMPTY else KNIGHT
            else if rook then KING  else PAWN
        else if bish
            then if rook then QUEEN else BISHOP
            else if rook then ROOK  else EMPTY

--- alternative to 'decodeFigure'
decodeF true  false false = PAWN
decodeF true  true  false = KNIGHT
decodeF false true  false = BISHOP
decodeF false false true  = ROOK
decodeF false true  true  = QUEEN
decodeF true  false true  = KING
decodeF _     _     _     = EMPTY

--- tells what is on the field that is indicated by the (singleton) 'Fields' set.
whatIs ∷ Position → Fields → FigInfo
whatIs p f = FI {player, piece, wo}
    where
        wo = (singleton . bitIndex) f
        player = if null (p.whites `inter` f) then BLACK else WHITE
        pawn = not $ null (p.pawnSet `inter` f)
        bish = not $ null (p.bishopSet `inter` f)
        rook = not $ null (p.rookSet `inter` f)
        piece = decodeFigure pawn bish rook

--- tells what is on the field that is indicated by the 'Index'
whatIsOn p = whatIs p . singleton

--- Place a 'Player's 'Piece' on a certain field or many fields at once.
--- If there is something on the target field(s), it will be removed.
--- It is possible to place 'EMPTY', in this case, 'Player' will be ignored.
place ∷ Player → Piece → Fields → Position → Position
place !player !piece !mask !p = P{flags, whites, pawnSet, bishopSet, rookSet}
    where 
        flags  = Position.flags p
        whites = if player == WHITE && piece != EMPTY 
                    then p.whites `union` mask 
                    else p.whites `diff`  mask
        pawnSet = if piece == PAWN || piece == KING || piece == KNIGHT
                    then p.pawnSet `union` mask
                    else p.pawnSet `diff`  mask
        bishopSet = if piece == BISHOP || piece == QUEEN || piece == KNIGHT
                    then p.bishopSet `union` mask
                    else p.bishopSet `diff`  mask
        rookSet = if piece == ROOK  || piece == QUEEN || piece == KING
                    then p.rookSet `union` mask
                    else p.rookSet `diff`  mask

placeFigure :: FigInfo → Position → Position
placeFigure fi p = place fi.player fi.piece fi.wo p

--- The set of fields a 'WHITE' 'PAWN' on some 'Index' can go potentially
pure native whitePawnTargets    frech.MDB.whitePawnTargets ∷ Index → Fields
--- The set of fields a 'BLACK' 'PAWN' on some 'Index' can go potentially
pure native blackPawnTargets    frech.MDB.blackPawnTargets ∷ Index → Fields

--- The set of fields a 'KNIGHT' on some 'Index' can go to
pure native knightTargets   frech.MDB.knightTargets   :: Index → Fields

--- The set of fields a 'KING' on some 'Index' can go to
pure native kingTargets     frech.MDB.kingTargets     :: Index → Fields

--- The set of fields a 'ROOK' on some 'Index' can go to if there are no non 'EMPTY' fields. 
pure native rookTargets     frech.MDB.rookTargets     :: Index → Fields

--- The set of fields a 'BISHOP' on some 'Index' can go to if there are no non 'EMPTY' fields.
pure native bishopTargets   frech.MDB.bishopTargets   :: Index → Fields

--- The set of fields that must be 'EMPTY' to make a 'BISHOP' move valid.
--- Returns a set with all fields if the move is never valid, for example
--- > canBishop A1 A2 == BitSet 0xFFFFFFFFFFFFFFFFL
--- > canBishop A1 B2 == empty  -- no EMPTY fields required
--- > canBishop A1 C3 == singleton B2
pure native canBishop       frech.MDB.canBishop       :: Index → Index → Fields

--- The set of fields that must be 'EMPTY' to make a 'ROOK' move valid.
--- Returns a set with all fields if the move is never valid, for example
--- > canRook A1 B2 == BitSet 0xFFFFFFFFFFFFFFFFL
--- > canRook A1 A2 == empty  -- no EMPTY fields required
--- > canRook A1 C1 == singleton B1
pure native canRook         frech.MDB.canRook         :: Index → Index → Fields

--- The set of fields that must be 'EMPTY' to make a 'WHITE' 'PAWN' move valid.
--- Returns a set with all bits set if the move is never valid.
--- Returns 'empty' if this is a capturing move, it needs to check in addition whether the target is occupied by the opponent.
--- Returns the target and the skipped field, if any, for forward moves.
pure native canWhitePawn    frech.MDB.canWhitePawn  ∷ Index → Index → Fields
pure native canBlackPawn    frech.MDB.canBlackPawn  ∷ Index → Index → Fields 

--- The set of fields from where a WHITE/BLACK pawn could attack
pure native attackingWhitePawns frech.MDB.targetOfWhitePawns ∷ Index → Fields
pure native attackingBlackPawns frech.MDB.targetOfBlackPawns ∷ Index → Fields 

drawBoard p = do
    let indexes = [[A8…H8], [A7…H7], [A6…H6], [A5…H5], [A4…H4], [A3…H3], [A2…H2], [A1…H1]]
        fis = map (map (showUTF . whatIsOn p)) indexes
        lines = map (joined "") fis
    mapM_ println lines



foldFields ∷ (Fields→α→α) → α → Fields → α
foldFields !f !a !s 
    | null s = a
    | otherwise = foldFields f (f m a) s'
        where
            !m  = singleton (bitIndex s)
            s' = s `diff` m

foldIndexes ∷ (Index→α→α) → α → Fields → α
foldIndexes !f !a !s 
    | null s = a
    | otherwise = foldIndexes f (f m a) s'
        where
            !m  = bitIndex s
            s' = s `diff` singleton m

filterFields ∷ (Index → Bool) → Fields → Fields
filterFields !f !s = go f s empty
    where
        go ∷ (Index→Bool) → Fields → Fields → Fields
        go !f !s !r
            | null s    = r
            | f to      = go f (s `diff` m) (r `union` m)
            | otherwise = go f (s `diff` m) r 
            where
                !to = bitIndex s 
                !m  = singleton to    

validBishopTargets, validRookTargets ∷ Position → Index → Fields → Fields
--- Computes where a 'BISHOP' on a given 'Index' actually can go in the 'Position', but restricted to certain fields.
validBishopTargets p from mask = go p (mask `inter` bishopTargets from) empty 
    where
        go ∷ Position → Fields → Fields → Fields
        go !p !s !r
            | null s = r
            | p.allEmpty (canBishop from to)    = go p (s `diff` m) (r `union` m)
            | otherwise                         = go p (s `diff` m)  r
            where
                !to = bitIndex s 
                !m  = singleton to    

--- Computes where a 'ROOK' on a given 'Index' actually can go in the 'Position', but restricted to certain fields.
validRookTargets p from mask = go p (mask `inter` rookTargets from) empty 
    where
        go ∷ Position → Fields → Fields → Fields
        go !p !s !r
            | null s = r
            | p.allEmpty (canRook from to)  = go p (s `diff` m) (r `union` m)
            | otherwise                     = go p (s `diff` m)  r
            where
                !to = bitIndex s 
                !m  = singleton to    


!emptyBoard = (P empty empty empty empty empty)
!initialBoard = Position.{flags = singleton A1 `union` Position.castlingBits} 
               . place WHITE PAWN (BitSet.fromList [A2, B2, C2, D2, E2, F2, G2, H2])
               . place BLACK PAWN (BitSet.fromList [A7, B7, C7, D7, E7, F7, G7, H7])
               . place WHITE KING (singleton E1)
               . place BLACK KING (singleton E8)
               . place WHITE QUEEN (singleton D1)
               . place BLACK QUEEN (singleton D8)
               . place WHITE ROOK (BitSet.fromList [A1, H1])
               . place BLACK ROOK (BitSet.fromList [A8, H8])
               . place WHITE KNIGHT (BitSet.fromList [B1, G1])
               . place BLACK KNIGHT (BitSet.fromList [B8, G8])
               . place WHITE BISHOP (BitSet.fromList [C1, F1])
               . place BLACK BISHOP (BitSet.fromList [C8, F8]) 
               $ emptyBoard

main = do
    drawBoard emptyBoard
    print "Knight: "
    println (knightTargets E4)
    print "King: "
    println (kingTargets E4)
    print "Rook: "
    println (rookTargets E4)
    print "Bishop: "
    println (bishopTargets E4)
    let b = foldFields (place BLACK PAWN) emptyBoard (bishopTargets E4)
    drawBoard (place WHITE BISHOP (singleton E4) b)