module frech.Eval where

import Data.Bits (BitSet, .^. , .&.)

import frech.Daten

--- Base values for 'Piece's in centipawns 
pieceValue EMPTY = 0
pieceValue PAWN  = 100
pieceValue KNIGHT = 300
pieceValue BISHOP = 300
pieceValue ROOK   = 500
pieceValue QUEEN  = 800
pieceValue KING   = 1000

--- take the value in favor of a certain 'Player'
forP ∷ Player → Int → Int
forP WHITE n = n
forP BLACK n = negate  n

--- discount n c m
--- discount n% from m if condition holds
discount !n !condition !m = if condition then m - ((m*n) `quot` 100) else m 

--- penalize player condition n
--- If condition holds, count n in favor of players opponent, else 0
penalize ∷ Player → Bool → Int → Int
penalize p c n = if c then forP p.opponent n else 0   

--- replaces 
--- > length (filter (==pos) history)
--- saving thunks 
countEqPos :: Position -> [Position] -> Int
countEqPos !pos !history = go pos history 0
    where
        go ∷ Position → [Position] → Int → Int
        go !p [] !n = n
        go !p (h:hs) !n
            | p == h    = go p hs (n+1)
            | otherwise = go p hs n 

--- 'Position' value when 'BLACK' is mate.
!blackIsMate = 999999
--- 'Position' value when 'WHITE' is mate.
!whiteIsMate = -999999

clearLowestBit f = BitSet (n .^. (n .&. negate n)) where !n = BitSet.set f

{--
    Evaluate a 'Position'

    Positive values indicate a 'Position' favourable for 'WHITE', whereas negative ones indicate 
    'BLACK' is ahead.
    
    Special values:
    
    1. 0 may indicate stalemate, repeated position or draw because of 50 moves rule.
    2. 999999 indicates 'BLACK' is mate.
    3. -999999 indicates 'WHITE' is mate.
-}

eval :: [Position] → Position → Int
eval history pos
    | mate = if pos.turn == BLACK then blackIsMate else whiteIsMate
    | stalemate = 0
    | pos.getPlyCounter >= 100 = 0 
    | countEqPos pos history >= 2 = 0
    | otherwise = go pos pos.figures 0 
                    + forP pos.turn (5 * length ms)
                    + forP pos.turn.opponent (5 * length oms)
                    + forP pos.turn.opponent checkBonus 
    where
        !ms = moves pos
        !oms = moves (if pos.turn == WHITE  then pos.{flags ← (`diff`  whiteToMove)} 
                                            else pos.{flags ← (`union` whiteToMove)})
        mate = null ms && check 
        stalemate = null ms && not mate
        check = inCheck pos pos.turn
        checkBonus = if check then 25 else 0
        -- compute a value for every 'Piece' and sum it up
        go ∷ Position → Fields → Int → Int
        go pos m n
            | null m = n
            | otherwise = go pos (m `diff` fx) (n + score pos ix)
            where
                !ix = bitIndex m
                !fx = singleton ix
        -- compute the value of a 'Piece'
        score ∷ Position → Index → Int
        score pos ix = forP fi.player (pieceValue fi.piece) + hanging
            where
                hanging = if isAttacked pos ix fi.player.opponent 
                                -- fi.player != pos.turn
                                -- not (isAttacked pos ix fi.player)
                        then forP fi.player.opponent (if isAttacked pos ix fi.player then 4 else 10)
                        else 0
                !fi = whatIsOn pos ix
