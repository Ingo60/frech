--- Basic data structures for the Chess engine
module frech.Data where

import Data.Bits
import Data.Bits (BitSet.union union, BitSet.member member)

infixl 13 union

data Index  = A1 | B1 | C1 | D1 | E1 | F1 | G1 | H1
            | A2 | B2 | C2 | D2 | E2 | F2 | G2 | H2
            | A3 | B3 | C3 | D3 | E3 | F3 | G3 | H3
            | A4 | B4 | C4 | D4 | E4 | F4 | G4 | H4
            | A5 | B5 | C5 | D5 | E5 | F5 | G5 | H5
            | A6 | B6 | C6 | D6 | E6 | F6 | G6 | H6
            | A7 | B7 | C7 | D7 | E7 | F7 | G7 | H7
            | A8 | B8 | C8 | D8 | E8 | F8 | G8 | H8
            where
                pure native toEnumCast "(short)" :: Int -> Index
                toEnum n | n >= 0 && n < 64 = toEnumCast n
                         | otherwise        = error ("Index.toEnum: bad index " 
                                                ++ show n 
                                                ++ " (must be 0..63)")
                read :: String  → Index
                read s = case s of 
                        '^[a-h][1-8]$' = toEnum ((row `shiftL` 3) + col)
                        other          = error ("not a valid field: " ++ s)
                    where
                        row = ord (s.charAt 1) - ord '1'
                        col = ord (s.charAt 0) - ord 'a'

deriving Enum Index
instance Show Index where
    show n = String.format "%c%c" (chr col) (chr row) :: String
        where
            row = ord '1' + (ord n `shiftR` 3)
            col = ord 'a' + (ord n .&. 7)

--- gives the bit number of the lowest bit
pure native bitNum java.lang.Long.numberOfTrailingZeros :: Long -> Int

--- give the 'Index' of the lowest bit. The 'Fields' set must not be empty!
bitIndex :: Fields → Index
bitIndex = Index.toEnumCast . bitNum . BitSet.set

--- A bit set for sets of fields
type Fields = BitSet Index

--- The players taking part in the game
data Player = BLACK | WHITE
deriving Enum Player
deriving Show Player


{--
    A position.
    This is what can be created from a FEN string. 
-}

data Position = P {
    {--
        Encodes castling, en passant position and who's turn it is.
        
        - If en passant is possible, one of  A3..H3 or A6..H6 is in the set
        - If castling is possible, the corresponding target fields of the Kings
        are in the set. This would be G1 (white kingside), C1 (white queenside),
        G8 (black kingside) or C8 (black queenside).
        - If A1 is in the set, it is 'WHITE's turn, otherwise 'BLACK's.     
    -}
    !flags   ::  Fields
    } where
        --- constant bitmask for selection of the castling information
        !castling = BitSet.singleton G1 
                    `union` BitSet.singleton C1 
                    `union` BitSet.singleton G8
                    `union` BitSet.singleton C8
        
        enPassantBlackPawn = [A6 .. H6]
        enPassantWhitePawn = [A3 .. H3]
        !enPassantFields = BitSet.fromList (enPassantBlackPawn ++ enPassantWhitePawn)
        
        turn p = if A1 `member` Position.flags p then WHITE else BLACK

