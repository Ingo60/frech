--- Basic data structures for the Chess engine
module frech.Data where

import Data.Bits
import Data.Bits (BitSet.union union, 
                    BitSet.member member, 
                    BitSet.difference diff, 
                    BitSet.intersection inter)

infixl 13 union diff
infixl 14 inter

data Index  = A1 | B1 | C1 | D1 | E1 | F1 | G1 | H1
            | A2 | B2 | C2 | D2 | E2 | F2 | G2 | H2
            | A3 | B3 | C3 | D3 | E3 | F3 | G3 | H3
            | A4 | B4 | C4 | D4 | E4 | F4 | G4 | H4
            | A5 | B5 | C5 | D5 | E5 | F5 | G5 | H5
            | A6 | B6 | C6 | D6 | E6 | F6 | G6 | H6
            | A7 | B7 | C7 | D7 | E7 | F7 | G7 | H7
            | A8 | B8 | C8 | D8 | E8 | F8 | G8 | H8
            where
                pure native toEnumCast "(short)" :: Int -> Index
                toEnum n | n >= 0 && n < 64 = toEnumCast n
                         | otherwise        = error ("Index.toEnum: bad index " 
                                                ++ show n 
                                                ++ " (must be 0..63)")
                read :: String  → Index
                read s = case s of 
                        '^[a-h][1-8]$' = toEnum ((row `shiftL` 3) + col)
                        other          = error ("not a valid field: " ++ s)
                    where
                        row = ord (s.charAt 1) - ord '1'
                        col = ord (s.charAt 0) - ord 'a'

deriving Enum Index
instance Show Index where
    show n = String.format "%c%c" (chr col) (chr row) :: String
        where
            row = ord '1' + (ord n `shiftR` 3)
            col = ord 'a' + (ord n .&. 7)

--- gives the bit number of the lowest bit
pure native bitNum java.lang.Long.numberOfTrailingZeros :: Long -> Int

--- give the 'Index' of the lowest bit. The 'Fields' set must not be empty!
bitIndex :: Fields → Index
bitIndex = Index.toEnumCast . bitNum . BitSet.set

--- A bit set for sets of fields
type Fields = BitSet Index

--- The players taking part in the game
data Player = BLACK | WHITE
deriving Enum Player
deriving Show Player


{--
    A position contains information about all figures on the board,
    as well where castling and en passant is possible and who's turn it is.
     
    This is what can be created from a FEN string. 
-}

data Position = P {
    {--
        Encodes castling, en passant position and who's turn it is.
        
        - If en passant is possible, one of  A3..H3 or A6..H6 is in the set
        - If castling is possible, the corresponding target fields of the Kings
        are in the set. This would be G1 (white kingside), C1 (white queenside),
        G8 (black kingside) or C8 (black queenside).
        - If A1 is in the set, it is 'WHITE's turn, otherwise 'BLACK's.     
    -}
    !flags   ::  Fields,
    --- Tells the fields that are occupied by white figures
    !whites  ::  Fields,
    --- Tells the fields that are occupied by 'PAWN's
    !pawns   ::  Fields,
    --- Tells the fields that are occupied by 'KNIGHT's
    !knights ::  Fields,
    --- Tells the fields that are occupied by 'BISHOP's
    !bishops ::  Fields,
    --- Tells the fields that are occupied by 'ROOK's
    !rooks ::  Fields,
    --- Tells the fields that are occupied by 'QUEEN's
    !queens ::  Fields,
    --- Tells the fields that are occupied by 'KING's
    !kings ::  Fields

  } where
    --- constant bitmask for selection of the castling information
    !castling = BitSet.singleton G1 
                `union` BitSet.singleton C1 
                `union` BitSet.singleton G8
                `union` BitSet.singleton C8
    
    enPassantBlackPawn = [A6 .. H6]
    enPassantWhitePawn = [A3 .. H3]
    !enPassantFields = BitSet.fromList (enPassantBlackPawn ++ enPassantWhitePawn)

    --- tell who's turn it is    
    turn p = if A1 `member` Position.flags p then WHITE else BLACK
    
    --- all figures
    figures :: Position → Fields
    figures p = p.pawns `union` p.knights `union` p.bishops `union` p.rooks `union` p.queens `union` p.kings
    
    --- white figures
    whiteFigures p = figures p `inter` whites p
    --- black figures
    blackFigures p = figures p `diff`  whites p
    --- figures of a give player
    playerFigures pos player = case player of
        WHITE → whiteFigures pos
        BLACK → blackFigures pos
    --- figures of the player whose turn it is
    activeFigures p = playerFigures p (turn p)
    


data Figure = PAWN | KNIGHT | BISHOP | ROOK | QUEEN | KING
deriving Enum Figure
instance Show Figure where
    show PAWN   = "P"
    show KNIGHT = "N"
    show BISHOP = "B"
    show ROOK   = "R"
    show QUEEN  = "Q"
    show KING   = "K"

data FigInfo = FI {!player :: Player, !figure :: Figure, !wo :: Index }
