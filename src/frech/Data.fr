--- Basic data structures for the Chess engine
module frech.Data 
    inline (Position.figures, decodeFigure, member, singleton, whatIsOn) where

import Data.Bits
import Data.Bits public (BitSet.union union, 
                    -- BitSet.member member, 
                    BitSet.difference diff, 
                    BitSet.intersection inter,
                    -- BitSet.singleton singleton
                    )

infixl 13 union diff
infixl 14 inter

{--
    # Geometry of the board
    
    > Rows  -- 8 --- -- 7 --- -- 6 --- -- 5 --- -- 4 --- -- 3 --- -- 2 --- -- 1 ---
    > Files hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba hgfedcba
    > Bits  ........ ........ ........ ........ ........ ........ ........ ........
    > 2^   63     56       48       40       32       24       16        8        0
    
    This means, a step to the *right* (i.e. a1-b1) corresponds to a *left* shift,
    a step to the *left* (i.e. g7-f7) corresponds to a *right* shift,
    a step to towards the eighth row (i.e. e4-e5) corresponds to 8 *left* shifts,
    and a step towards the first row (i.e. c8-c7) corresponds to 8 *right* shifts.
--}
data Index  = A1 | B1 | C1 | D1 | E1 | F1 | G1 | H1
            | A2 | B2 | C2 | D2 | E2 | F2 | G2 | H2
            | A3 | B3 | C3 | D3 | E3 | F3 | G3 | H3
            | A4 | B4 | C4 | D4 | E4 | F4 | G4 | H4
            | A5 | B5 | C5 | D5 | E5 | F5 | G5 | H5
            | A6 | B6 | C6 | D6 | E6 | F6 | G6 | H6
            | A7 | B7 | C7 | D7 | E7 | F7 | G7 | H7
            | A8 | B8 | C8 | D8 | E8 | F8 | G8 | H8
            where
                pure native toEnumCast "(short)" :: Int -> Index
                toEnum n | n >= 0 && n < 64 = toEnumCast n
                         | otherwise        = error ("Index.toEnum: bad index " 
                                                ++ show n 
                                                ++ " (must be 0..63)")
                read :: String  → Maybe Index
                read s = case s of 
                        '^[a-h][1-8]$' = Just $ toEnum ((row `shiftL` 3) + col)
                        other          = Nothing
                    where
                        row = ord (s.charAt 1) - ord '1'
                        col = ord (s.charAt 0) - ord 'a'

deriving Enum Index
instance Show Index where
    show n = String.format "%c%c" (chr col) (chr row) :: String
        where
            row = ord '1' + (ord n `shiftR` 3)
            col = ord 'a' + (ord n .&. 7)

--- gives the bit number of the lowest bit
pure native bitNum java.lang.Long.numberOfTrailingZeros :: Long -> Int

--- give the 'Index' of the lowest bit. The 'Fields' set must not be empty!
bitIndex :: Fields → Index
bitIndex = Index.toEnumCast . bitNum . BitSet.set

--- make a singleton 'Fields' set
singleton :: Index -> Fields
singleton x = BitSet (1L `shiftL` ord x)

--- is some 'Index' member of a 'Fields' set?
member :: Index -> Fields -> Bool
member i s = ((1L `shiftL` ord i) .&. BitSet.set s) != 0

--- A bit set for sets of fields
type Fields = BitSet Index

--- The players taking part in the game
data Player = BLACK | WHITE
deriving Enum Player
deriving Show Player

--- The shade of fields
data Shade = LIGHT | DARK
instance Show Shade where
    show LIGHT = "░"
    show DARK  = "▒"
    
indexShade ∷ Index → Shade
indexShade n = if even row == even col then DARK else LIGHT 
    where
        row = ord n `shiftR` 3
        col = ord n .&. 7

{--
    A position contains information about all figures on the board,
    as well where castling and en passant is possible and who's turn it is.
     
    This is what can be created from a FEN string. 
-}

data Position = P {
    {--
        Encodes castling, en passant position and who's turn it is.
        
        - If en passant is possible, one of  A3..H3 or A6..H6 is in the set
        - If castling is possible, the corresponding target fields of the Kings
        are in the set. This would be G1 (white kingside), C1 (white queenside),
        G8 (black kingside) or C8 (black queenside).
        - If A1 is in the set, it is 'WHITE's turn, otherwise 'BLACK's.     
    -}
    !flags   ::  Fields,
    --- Tells the fields that are occupied by white figures
    !whites  ::  Fields,
    {-- 
        For encoding of figures, we use only 3 sets instead of 6, namely        
        'Position.pawnSet', Position.bishopSet' and 'Position.rookSet', with the following
        convention:
        
        > Set       P      B     R
        > PAWN      x      -     -
        > KNIGHT    x      x     -
        > BISHOP    -      x     -
        > ROOK      -      -     x
        > QUEEN     -      x     x
        > KING      x      -     x
    
    --}
    !pawnSet, !bishopSet, !rookSet :: Fields,
  } where
    
    --- Tell the fields occupied by 'PAWN's
    --- 'PAWN's have a bit in 'Position.pawnSet' only.
    pawns p = pawnSet p `diff` bishopSet p `diff` rookSet p
    
    --- Tell the fields occupied by 'KNIGHT's
    --- 'KNIGHT's have a bit in 'Position.pawnSet' and 'Position.bishopSet' but not in 'Position.rookSet'.
    knights p = (pawnSet p `inter` bishopSet p) `diff` rookSet p
    
    --- Tell the fields occupied by 'BISHOP's
    --- 'BISHOPS's have a bit in 'Position.bishopSet' only.
    bishops p = (bishopSet p `diff` pawnSet p) `diff` rookSet p

    --- Tell the fields occupied by 'BISHOP's
    --- 'BISHOPS's have a bit in 'Position.bishopSet' only.
    rooks p = (rookSet p `diff` pawnSet p) `diff` bishopSet p

    --- Tell the fields occupied by 'QUEEN's
    --- 'QUEEN's have a bit both in 'Position.rookSet' and 'Position.bishopSet', but not in 'Position.pawnSet' 
    queens p = (bishopSet p `inter` rookSet p) `diff` pawnSet p
    
    --- Tell the fields occupied by 'KING's
    --- 'KING's have a bit both in 'Position.pawnSet' and 'Position.rookSet', but not in 'Position.bishopSet'.
    kings p = (rookSet p `inter` pawnSet p) `diff` bishopSet p

    
    --- constant bitmask for selection of the castling information
    !castlingBits = BitSet.singleton G1 
                `union` BitSet.singleton C1 
                `union` BitSet.singleton G8
                `union` BitSet.singleton C8
    
    !enPassantBits = BitSet.fromList (enPassantBlackPawn ++ enPassantWhitePawn)
        where
            enPassantBlackPawn = [A6 .. H6]
            enPassantWhitePawn = [A3 .. H3]

    --- tell who's turn it is    
    turn p = if A1 `member` Position.flags p then WHITE else BLACK
    
    --- all figures
    figures :: Position → Fields
    figures p = p.pawnSet `union` p.bishopSet `union` p.rookSet
    
    --- white figures
    whiteFigures p = figures p `inter` whites p
    --- black figures
    blackFigures p = figures p `diff`  whites p
    --- figures of a give player
    playerFigures pos player = case player of
        WHITE → whiteFigures pos
        BLACK → blackFigures pos
    --- figures of the player whose turn it is
    activeFigures p = playerFigures p (turn p)

    
deriving Show Position

data Figure = EMPTY | PAWN | KNIGHT | BISHOP | ROOK | QUEEN | KING
deriving Enum Figure
instance Show Figure where
    show EMPTY  = "?"
    show PAWN   = "P"
    show KNIGHT = "N"
    show BISHOP = "B"
    show ROOK   = "R"
    show QUEEN  = "Q"
    show KING   = "K"
    
--- Answer to the question "What is on field xy?"
--- If it's 'EMPTY', the 'FigInfo.player' is meaningless. 
data FigInfo = FI {!player :: Player, !figure :: Figure, !wo :: Fields }
-- ♔♕♖♗♘♙♚♛♜♝♞♟

showUTF ∷ FigInfo → String
showUTF fi = case fi.figure of 
    PAWN    → if fi.player == WHITE then "♙" else "♟"
    KNIGHT  → if fi.player == WHITE then "♘" else "♞"
    BISHOP  → if fi.player == WHITE then "♗" else "♝"
    ROOK    → if fi.player == WHITE then "♖" else "♜"
    QUEEN   → if fi.player == WHITE then "♕" else "♛"
    KING    → if fi.player == WHITE then "♔" else "♚"
    EMPTY   → show . indexShade . bitIndex $ fi.wo 

--- what figure is it, based on combination of pawn, bishop and rook bit?
decodeFigure !pawn !bish !rook = 
    if pawn 
        then if bish
            then if rook then EMPTY else KNIGHT
            else if rook then KING  else PAWN
        else if bish
            then if rook then QUEEN else BISHOP
            else if rook then ROOK  else EMPTY

--- alternative to 'decodeFigure'
decodeF true  false false = PAWN
decodeF true  true  false = KNIGHT
decodeF false true  false = BISHOP
decodeF false false true  = ROOK
decodeF false true  true  = QUEEN
decodeF true  false true  = KING
decodeF _     _     _     = EMPTY

--- tells what is on the field that is indicated by the (singleton) 'Fields' set.
whatIs ∷ Position → Fields → FigInfo
whatIs p f = FI {player, figure, wo}
    where
        wo = (singleton . bitIndex) f
        player = if null (p.whites `inter` f) then BLACK else WHITE
        pawn = not $ null (p.pawnSet `inter` f)
        bish = not $ null (p.bishopSet `inter` f)
        rook = not $ null (p.rookSet `inter` f)
        figure = decodeFigure pawn bish rook

--- tells what is on the field that is indicated by the 'Index'
whatIsOn p = whatIs p . singleton

--- place a 'Player's 'Figure' on a certain field
--- *Note*: cannot be used to remove a figure
place ∷ Player → Figure → Fields → Position → Position
place player figure mask p = P{flags, whites, pawnSet, bishopSet, rookSet}
    where 
        flags  = Position.flags p
        whites = if player == WHITE then p.whites `union` mask else p.whites
        pawnSet = if figure == PAWN || figure == KING || figure == KNIGHT
                    then p.pawnSet `union` mask
                    else p.pawnSet
        bishopSet = if figure == BISHOP || figure == QUEEN || figure == KNIGHT
                    then p.bishopSet `union` mask
                    else p.bishopSet
        rookSet = if figure == ROOK  || figure == QUEEN || figure == KING
                    then p.rookSet `union` mask
                    else p.rookSet 

placeFigure :: FigInfo → Position → Position
placeFigure fi p = place fi.player fi.figure fi.wo p

drawBoard p = do
    let indexes = [[A8…H8], [A7…H7], [A6…H6], [A5…H5], [A4…H4], [A3…H3], [A2…H2], [A1…H1]]
        fis = map (map (showUTF . whatIsOn p)) indexes
        lines = map (joined "") fis
    mapM_ println lines

emptyBoard = (P empty empty empty empty empty)

main = do
    drawBoard emptyBoard